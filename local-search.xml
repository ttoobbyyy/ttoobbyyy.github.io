<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>生活记录--九寨沟版</title>
    <link href="/2024/08/30/%E7%94%9F%E6%B4%BB%E8%AE%B0%E5%BD%95--%E4%B9%9D%E5%AF%A8%E6%B2%9F%E7%89%88/"/>
    <url>/2024/08/30/%E7%94%9F%E6%B4%BB%E8%AE%B0%E5%BD%95--%E4%B9%9D%E5%AF%A8%E6%B2%9F%E7%89%88/</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/ttoobbyyy/images/piclist/202408301333044.png"></p><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>一直都是更新技术文章，感觉好好记录一下生活也是很有趣的。刚好最近生活发生了比较大的变动。随意记录一下。</p><h3 id="工作"><a href="#工作" class="headerlink" title="工作"></a>工作</h3><p>跳槽了。想想毕业也两年了，在公司感觉上升通道有限，想换一个更大的平台。为此准备了半年多，整个准备下来，感觉和当初校招差不多，面试的内容差不多，唯一的区别是去掉了很多计算机原理的问题，基本没有碰到计算机网络和操作系统相关问题。<br>而且个人感觉，如果简历中没有什么比较特别的亮点，那么面试纯粹就是看运气了，因为对于面试官来说，他要求的技术能力没有那么高，面试者好好准备一两个月，就差不多能应付了。所以失败了，也没有必要过于难受，万一下一个就能碰到死耗子呢~<br>在上家公司离职的时候，被 hr 卡了一个月，这个倒是我没有想到的，tl 都选择放人了。</p><h3 id="旅游"><a href="#旅游" class="headerlink" title="旅游"></a>旅游</h3><p>去九寨沟了。和阿蓝一起去的，玩了大概 7 天。这还是和她在一起之后第一次出去旅游，都说长时间旅行能看出两人合不合适。实验下来，好像没有出现什么大问题，这个挺开心的。<br>旅游地点是阿蓝选的，她去过很多地方玩，说九寨沟是她的一个执念，事实证明，九寨沟确实配得上，哈哈哈哈哈哈哈哈哈。<br>水特别好看，像蓝宝石一样！尤其要夸一下景区的管理，非常多的观光车，早上 8 点到大门口就已经排了非常长的队伍了，然而没等 5 分钟就成功坐上观光车了。景区非常大，但由于交通特别方便，我们除了原始森林，基本都逛完了所有景点。<br>还去了黄龙，相比于九寨沟差的有点多，如果时间有限，只去九寨沟就好了。</p><h3 id="Fire"><a href="#Fire" class="headerlink" title="Fire"></a>Fire</h3><p>“fire”是一种生活方式。理念是远离消费主义，倡导极简主义，尽可能让自己早点退休。<br>这个是我最近思考如何对付程序员中年危机得到的结论。程序员的职业生涯其实非常适合“fire”。前期快速积累资金，后期靠前期资本获得一些被动收入。不过有些点还是得注意：</p><ol><li>消费观尽可能偏向极简主义，如果你的消费观做不到，那么一直好好工作才适合你</li><li>培养起自己非常感兴趣的爱好，最好能一直带来反馈的，能持久下去的。这个对我来说还是挺难的。但非常重要，后期提早退休将会获得大量空闲时间，如果没有自己很热爱的，那么时间将会特别无聊，难熬。</li><li>如果有另一半，那么最好另一半的想法和你差不多，不一致的话会特别难受的。阿蓝的想法和我是差不多的，她不是那种消费主义的，不过让她很“节流”还是有点困难，所以我后期的方向是尽可能“开源”。<br>每个人都有自己选择的生活方式，哪种“主义”都是对的，生活嘛，开心最重要！</li></ol>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
      <tag>生活日常</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库事务--分布式事务(4)</title>
    <link href="/2024/08/14/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1--%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1(4)/"/>
    <url>/2024/08/14/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1--%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1(4)/</url>
    
    <content type="html"><![CDATA[<p>谈及分布式事务，就必须涉及多个服务，多个数据源。既然还是属于事务，那么目的还是尽可能保证数据一致性，只不过手段上，不能像传统事务那么简单的在单数据源上解决问题。</p><h3 id="例子引入"><a href="#例子引入" class="headerlink" title="例子引入"></a>例子引入</h3><p>下面笔者尝试根据自己有限的理论介绍清楚分布式事务，到底解决什么问题，各个解决方案有什么问题。<br>首先引入，分布式事务中常用例子，一个电商场景中用户购买商品，涉及仓储服务，订单服务，账户服务。<br><img src="https://cdn.jsdelivr.net/gh/ttoobbyyy/images/piclist/202408141439335.png"><br>用代码来表示就是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OrderServiceImpl</span>&#123;<br><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">public</span> StockService stockService;<br><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">public</span> UserService userService;<br><span class="hljs-meta">@Resource</span><br><span class="hljs-keyword">public</span> OrderMapper orderMapper;<br><br><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">order</span><span class="hljs-params">()</span>&#123;<br><span class="hljs-comment">// 保存订单</span><br>orderMapper.save();<br><span class="hljs-comment">// 预扣库存</span><br>stockService.save();<br><span class="hljs-comment">// 扣减资金</span><br>userService.save();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的执行顺序还有待考量，在实践中尽可能<strong>将本地操作，和最容易出错的操作先执行</strong>。如果我们可以保证每个 sql 都可以执行成功，那么确实也不需要什么额外措施。然而，物理机器和网络是不可靠的，任意的 sql 执行失败，都会导致数据的不一致。<br>比如，我们很自然想到为方法加上本地事务（可以简单的为方法加上@Transaction 注解），当订单服务，库存服务的 sql 执行失败，都可以正确的回滚。而当账户服务的 sql 执行失败了，抛出了异常，订单服务可以正常回滚，然而库存服务无法感知到这一点，数据不一致了。<br>这里存在问题的根因是，不同服务之间的状态无法感知，那么，让服务之间互相感知一般有两种方式，一种是服务之间互相通信，另一种有一个中心管理者来管理所有服务，显然第一种方案的通信成本会随着服务数量增多而显著增加。所以，工程上，一般都是<strong>添加第三方管理者</strong>。<br><img src="https://cdn.jsdelivr.net/gh/ttoobbyyy/images/piclist/202408141439858.png"></p><h3 id="2PC"><a href="#2PC" class="headerlink" title="2PC"></a>2PC</h3><p>引入一个中心管理者，其核心思想其实就是二阶段提交。<br>第一阶段：各个微服务提交事务，并且将执行状态上报给中心管理者<br>第二阶段：中心管理者根据各个微服务的执行情况，给与反馈，只有所有微服务都成功了，才能提交分布式事务，否则就回滚</p><h4 id="3PC"><a href="#3PC" class="headerlink" title="3PC"></a>3PC</h4><ol><li>3pc 比 2pc 多了一个 can commit 阶段，减少了不必要的资源浪费。因为 2pc 在第一阶段会占用资源，而 3pc 在这个阶段不占用资源，只是校验一下 sql，如果不能执行，就直接返回，减少了资源占用。（这里资源占用是指对资源进行加锁了）</li><li>引入超时机制。同时在协调者和参与者中都引入超时机制。<br> 2pc: 只有协调者有超时机制，超时后，发送回滚指令。<br> 3pc: 协调者和参与者都有超时机制。<br> 协调者超时: can commit，pre commit 中，如果收不到参与者的反馈，则协调者向参与者发送中断指令。<br> 参与者超时: pre commit 阶段，参与者进行中断; do commit 阶段，参与者进行提交。</li></ol><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><p>基于上述的理论，工程上已经有多种模式可以使用了。</p><h4 id="XA-模式"><a href="#XA-模式" class="headerlink" title="XA 模式"></a>XA 模式</h4><p>XA 其实可以理解为分布式事务处理（DTP，distribute transaction process）的一个处理规范协议，有很多数据库已经支持了。<br>XA 模式将组件分为三种角色<br>AP（application）：开启全局事务的应用程序<br>TM（transaction manager）：全局事务管理器，管理全局事务和各个子事务的状态<br>RM（resource manager）：资源管理器，参与者需要实现 XA 协议，因此一般都是数据库来承担。可见这个模式对代码侵入性比较小<br>执行过程：</p><ol><li>准备阶段：rm 本地提交本地子事务，但不写入最后的 commit record（即：不释放锁资源）。将执行结果通知给 tm</li><li>执行阶段：tm 根据各个子事务的结果，让 rm 们进行 commit&#x2F;rollback<br>特点：</li><li>强一致性</li><li>性能差劲：整个过程有三次持久化（准备阶段 rm 写 redo 日志，tm 做状态持久化，提交阶段 rm 写入提交日志），两次远程调用。而且具有木桶效应，最慢的 rm 不完成任务，其他 rm 不能释放锁资源</li><li>单点效应：rm 宕机了，可以在 rm 的提交结果过程引入超时机制，但 tm 的回复过程宕机了，无法处理。需要做好 tm 集群的高可用</li></ol><h4 id="AT-模式"><a href="#AT-模式" class="headerlink" title="AT 模式"></a>AT 模式</h4><p>在 AT 模式下，业务基本无感知的，都是通过 seate 做了一层代理来实现功能的。<br>事务执行过程：</p><ol><li>准备阶段：Seata 会拦截“业务 SQL”，首先解析 SQL 语义，找到“业务 SQL”要更新的业务数据，在业务数据被更新前，将其保存成“before image”，然后执行“业务 SQL”更新业务数据，在业务数据更新之后，再将其保存成“after image”，最后生成框架行锁。以上操作全部在一个数据库事务内完成。</li><li>执行阶段：<ol><li>commit：将“before image”和“after image”删除，释放框架行锁</li><li>rollback：将对应的数据和“after image”进行对比，如果数据一致，说明这个过程没有发生脏写（虽然有行锁，但是这是框架层面的，不能排除有其他数据库连接修改了数据，还是可能会脏写），直接把数据还原为“before image”。如果数据不一致，则必须人工介入<br>可以看出 AT 模式和 XA 模式特别像，都是 2PC 的典型应用，不过有两点不同：</li></ol></li><li>AT 模式的 RM 是业务应用，不是数据库处理的。</li><li>AT 模式在准备阶段会直接提交本地事务，不会占用锁资源，避免了木桶效应。（这里值得一提的是，seata 虽然释放了本地锁资源，但是会保存一个框架级别的“全局锁”，这个锁是行锁，用于做写隔离效果的）<br>这个模式是一个使用比较广泛的分布式事务解决方案</li></ol><h4 id="TCC-模式"><a href="#TCC-模式" class="headerlink" title="TCC 模式"></a>TCC 模式</h4><p>上面介绍的两种模式都是业务侵入性比较小的方案。也正是因为它的业务侵入性比较小，导致它的灵活性不够，只能基于 sql 维度解决问题。<br>TCC 主要有三个步骤，也是两个阶段：</p><ul><li>Try：预留资源</li><li>Confirm：执行的业务操作提交</li><li>Cancel：预留的资源释放<br>这三个步骤的划分都是基于业务上的，我们在使用这个模式的时候首先就得把业务模型拆为两阶段。<br>举一个扣 100 元的例子，try 阶段就得冻结用户 100 元，confirm 阶段就直接提交，cancel 阶段就撤销冻结操作。但是，“冻结”操作我们有很多实现方式，可以新建一张金钱冻结数据表，或者依据什么高可靠的消息队列，不需要像 XA 模式保留锁资源，或者像 AT 模式保留一个框架全局行锁。这种模式的灵活性高很多，带来的性能也会高很多。就是对业务侵入比较强。<br>在此基础上再提出几个只有再业务层面才能实现的技术点：</li></ul><ol><li>允许空回滚：try 操作失败了，rm 收到了 cancel 命令，此时 rm 没有发现事务 id 时也需要能回滚成功</li><li>防悬挂设计：悬挂的意思是 cancel 比 try 更先执行。比如，try 操作超时了，cancel 回滚成功，此时 try 命令又来了，rm 就不应该可以再执行 try 命令了，否则就会数据不一致</li><li>幂等性：其实，分布式系统的场景下，尽可能所有接口都设计成幂等的。因为网络是不稳定的，我们会通过重试操作来减少这种不稳定带来的影响，术语叫做“最大努力交付”。<br>这些技术点，基本都需要业务的参与。</li></ol><h4 id="SAGA-模式"><a href="#SAGA-模式" class="headerlink" title="SAGA 模式"></a>SAGA 模式</h4><p>这个模式的核心思想是将一个长的分布式事务，分解为一个个子事务，并且为子事务设计补偿操作。只要所有子事务可以正确提交，分布式事务就算正确提交了。如果有的子事务无法正确提交，那么有两种操作：</p><ol><li>正向恢复：重复尝试失败的子事务，做到“最大努力交付”，这种适用于事务必须要成功的场景</li><li>反向恢复：执行目前已经执行了的子事务的补偿操作。如果补偿操作失败，也得做到“最大努力交付”。否则让人工介入<br>SAGA 必须保证所有子事务都得提交或者补偿，但 SAGA 系统本身也可能崩溃，所以系统本身也得做到高可用。<br>这个模式的业务侵入性也很强，因为补偿是在业务层面做的。这个和回滚不太一样，它需要业务的参与。比如扣 100 元钱，补偿是指加上 100 元，而回滚是撤销扣钱的操作。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>事务的目的是保证数据一致性，本地事务的执行过程保证了无论系统在什么场景下，数据都是一致的。<br>但是在分布式的场景下，可以看到，这四种模式有各自的优缺点，没有一种模式适合所有的场景，因地制宜才是最好的选择。<br>分布式系统的引入，带来了机遇，也带来了技术挑战，分布式系统在极端场景下需要人工的介入才能保证数据一致性。<br>当然，除了分布式事务这种“很重”的操作，在很多业务场景中，我们还是会选择使用“最终一致性”这种性能更高的方案，还是要因“场景”制宜的。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p>seata 官网： <a href="https://seata.io/zh-cn/docs/dev/mode/at-mode.html">Seata AT 模式</a><br>AT 模式的行锁：<a href="https://juejin.cn/post/7164254193362927624">Seata AT模式原来是这样实现行锁的 - 掘金 (juejin.cn)</a><br>《凤凰架构》：<a href="http://icyfenix.cn/">凤凰架构：构建可靠的大型分布式系统 | 凤凰架构 (icyfenix.cn)</a></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>事务</tag>
      
      <tag>分布式系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式系统知识大纲</title>
    <link href="/2024/03/29/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    <url>/2024/03/29/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文将简单介绍分布式系统涉及的技术点，可以作为一个学习大纲。后续还需要深入的学习其中的知识点。</p></blockquote><p><img src="https://raw.githubusercontent.com/ttoobbyyy/images/master/20240329221306.png"></p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>互联网的繁荣发展给每个人的生活带来了翻天覆地的变化。而这些对于提供互联网服务的公司也带来的大流量的压力，传统的单机承接不了这么大的流量压力，哪怕是升级机器配置也有承受的上限！<br>而 <code>分布式系统</code> 就是来解决这个问题的，它可以理解为多个普通计算机节点联合起来一起工作，对客户端而言，就像只有一台单机在工作一般，理论上分布式系统是可以无限扩展的。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>弹性高：分布式系统的节点数量可以动态增删</li><li>成本低：多个普通节点可以完成一个高配置机器能完成的任务</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>极大的提高了运维复杂度。假如一台机器故障概率是 1%，那么 10 台机器可能导致故障概率是 <code>（1-（1-0.01）^10）= 9.5%</code>。在分布式环境下，机器出故障的概率会大大增加。</p><h3 id="理论基础"><a href="#理论基础" class="headerlink" title="理论基础"></a>理论基础</h3><h4 id="CAP-定理"><a href="#CAP-定理" class="headerlink" title="CAP 定理"></a>CAP 定理</h4><p>这个定理是分布式系统理论上的一个基本准则，指的是以下三种特性只能保障两个：<br>C：一致性，指的是多个节点对外提供一致的数据。（这样描述不够准确，我们可以理解为客户端同一时刻访问分布式系统的任意一个节点，获取到的数据是一样的）<br>A：可用性，指的是系统中任意一个节点发生问题时，数据和其他节点不一致，是否选择让它还对外提供服务。如果继续服务，则说明系统选择了可用性。<br>P：网络分区，只要节点是通过网络进行交互的，则一定会发生网络分区，如果发生分区，就不对外提供服务，那么这个系统将极其不可靠。<br>因此，我们一般会根据场景选择 CP 或者 AP 系统。<br>不过，这里的一致性指的是 <code>强一致性</code>，在实际应用中，实现它代价太大了，于是理论上的 CAP 定理，到工程实践上就变成了 <code>BASE</code> 理论。<br>basically available：基本可用，允许系统丧失部分可用性<br>soft state：软状态，允许系统的数据存在中间状态，也就是允许客户端访问到过期数据<br>eventually consistent：最终一致性，系统最后会达到一致的状态，不保证实时达到一致性。</p><h4 id="有状态应用"><a href="#有状态应用" class="headerlink" title="有状态应用"></a>有状态应用</h4><p>上面的定理的应用对象就是 <code>有状态应用</code>，指的是应用中存在数据，如果数据完全在第三方数据源上，应用无状态，那么这个分布式系统无论怎么折腾都可以，节点可以任意故障。</p><blockquote><p>一般来说，我们希望业务应用能做到是无状态应用，然而有时候不可避免会保留本地缓存，如何保持这份本地缓存的一致性也是一个挑战，一个行之有效的方法是设置缓存的随机失效时间</p></blockquote><h4 id="共识算法"><a href="#共识算法" class="headerlink" title="共识算法"></a>共识算法</h4><p>共识指的是分布式系统多个节点就某一个提议达成了一致。<br>这么说有点抽象，要注意的是共识算法并不等同于实现了强一致性，它还存在一些限制。比如一个实现典型 raft 算法的分布式系统，只能通过主节点进行读写操作，其他节点只能当作副本。<br>不过在现实中很多场景问题都可以等价为共识问题：</p><ul><li>原子事务提交</li><li>全序广播</li><li>分布式锁和租约</li><li>选主</li></ul><h4 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h4><p>一致性在分布式系统是一个很“晦涩”的话题。<br>最理想的环境下，我们希望整个分布式系统可以当作一个单机来看待，就没有什么一致性的问题了。也可以说整个系统做到了“强一致性”。<br>然而现实是，做到强一致性代价太大了，就有了各种妥协。分布式系统有两个固有的缺陷，第一个是前文提及的节点随时会失效；另一个就是和一致性相关的缺少一个 <code>全序时钟</code>，每个节点的时钟不能保证一致。那么客户端访问不同节点的操作就无法通过时间戳确定先后顺序。<br>在一些场景下，两个操作之间有依赖关系。于是衍生出“顺序一致性”，“最终一致性”，“因果一致性”等多种一致性概念。</p><h4 id="分布式事务"><a href="#分布式事务" class="headerlink" title="分布式事务"></a>分布式事务</h4><p>和本地事务不同，分布式事务是多个数据源共同参与的，目的也是追求数据逻辑的一致性。而这一点和共识算法有一点点相似的地方，两者都是为了做到数据的一致性。而且原理上都有一点用到了 <code>2pc</code> 的思想。<br>2pc 核心在于有一个预提交的中间状态，这个中间状态让各个节点可以感知其他节点的情况，进行回滚或者提交！当然，它必然是中心化的系统，需要一个事务协调节点。这就带来了单点问题，就有更为复杂的 <code>3pc</code> 方案</p><h3 id="“三高”追求"><a href="#“三高”追求" class="headerlink" title="“三高”追求"></a>“三高”追求</h3><p>三高，是每一个架构设计所追求的！</p><h4 id="高可靠-高可用"><a href="#高可靠-高可用" class="headerlink" title="高可靠 &amp; 高可用"></a>高可靠 &amp; 高可用</h4><p>高可靠和高可用是类似概念，指的是一个服务能连续提供服务的时长，也就是服务很稳定，很可靠，另一个层面来说，就算遇到问题，也能保证关键数据不丢失！<br>一般来说会涉及很多方面的问题，如硬件，软件，网络，运维等。而解决方案似乎出奇的一致：<strong>复制</strong>。由此衍生的名词有，主从复制，副本机制，异地多活，故障转移等。</p><h4 id="高性能"><a href="#高性能" class="headerlink" title="高性能"></a>高性能</h4><p>高性能指的就是系统可以承受多大的流量，一般来说节点越多，性能越好。然而对于有状态应用，还有诸多限制。关于这一方面也有很多名词：读写分离，集群机制，哨兵机制，数据分区等</p><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><h4 id="服务注册和发现"><a href="#服务注册和发现" class="headerlink" title="服务注册和发现"></a>服务注册和发现</h4><p>这个点本不应该放入分布式系统中来讲的，这个更多的是微服务的概念，微服务之间采用 RPC 进行通信。需要服务注册和发现的过程。</p><h4 id="分布式消息队列"><a href="#分布式消息队列" class="headerlink" title="分布式消息队列"></a>分布式消息队列</h4><p>消息队列作为一个典型案例来讲解。它涉及了数据分区，副本机制，主从切换等常见分布式数据系统遇到的问题。<br>数据同步到多副本的过程还存在一个复制模型的选择问题：</p><ol><li>同步复制：所有副本 ack 再返回</li><li>半同步复制：部分数量的副本 ack 后返回</li><li>异步复制：不等待副本 ack 直接返回<br>而对于消息队列本身，还有一个消费模型的语义选择：</li><li>至多一次消费：每个消息最多消费一次</li><li>至少一次消费：每个消息至少消费一次</li><li>只消费一次：每个消息会且只会消费一次，这需要依靠消息幂等性和消息事务来实现。不同消息队列产品实现的方式不一致</li></ol><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://blog.csdn.net/guyue35/article/details/125211496">共识、线性一致性、顺序一致性、最终一致性、强一致性讲解_最终一致性和强一致性-CSDN博客</a><br><a href="https://qiankunli.github.io/2022/04/06/replica_consistency_level.html">多角度理解一致性 | 李乾坤的博客 (qiankunli.github.io)</a><br><a href="https://mp.weixin.qq.com/s/O9Z5e_BzdxKcULHigYMkRg">Replication（下）：事务，一致性与共识 (qq.com)</a><br><a href="https://mp.weixin.qq.com/s/LB5SR4ypQwDxzueI1ai2Kg">Replication（上）：常见的复制模型&amp;分布式系统的挑战 (qq.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>架构设计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>DDD学习笔记</title>
    <link href="/2024/01/27/DDD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/01/27/DDD%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文是博客学习笔记，可以说是缝合怪，原文在后面的参考链接中</p></blockquote><h3 id="什么是-DDD"><a href="#什么是-DDD" class="headerlink" title="什么是 DDD"></a>什么是 DDD</h3><h4 id="与传统架构的差异"><a href="#与传统架构的差异" class="headerlink" title="与传统架构的差异"></a>与传统架构的差异</h4><p>常见的业务三层架构：<br><img src="https://raw.githubusercontent.com/ttoobbyyy/images/master/5df8788dcea6a4138d6c86166ce32df.png"></p><p>再看 DDD 的架构：<br><img src="https://raw.githubusercontent.com/ttoobbyyy/images/master/20240127133033.png"><br>来看两者的区别：</p><ul><li>DDD 架构中，分为了接口层，应用层，领域层，基础设施层。相比于原来的三层模型，可以认为 DDD 讲业务层拆分为了应用层和领域层。其中，应用层主要是做业务逻辑的组装，它会调用基础设施和领域层的接口来组装业务。而领域层则是一些核心的业务操作，最关键的是，它是<strong>纯内存操作</strong>。于是我们可以这样理解，DDD 将一些核心业务的操作从业务层剥离出来了！</li><li>UI 层和接口层是类似的</li><li>基础设施层包含了一切和外部应用交互的接口。可以说是包含了原来数据访问层的内容</li></ul><h4 id="理论解释"><a href="#理论解释" class="headerlink" title="理论解释"></a>理论解释</h4><p>领域驱动设计（domain driven design）。首次出现在十几年前，却在微服务时代大放光彩。 <strong>DDD 是作为一种战略思想可用于指导微服务的拆分,DDD 本质不是一个软件架构, 而是一种指导思想</strong>。它涉及的术语很多，简单介绍几个我印象比较深刻的。</p><ul><li>领域对象（Entity）：最重要的概念模型，可以理解和数据表有一种映射关系。然而又不会和数据表直接交互。它<strong>完全是内存操作，不会有外部依赖</strong>（ps：理解这一点很重要，这是整个 DDD 能做到高内聚的核心）</li><li>值对象（Value Object）：相比于 Entity，它不需要和数据表有映射关系，可以理解为一种更为基础的概念模型，同样的，它也完全内存操作，没有外部依赖</li><li>领域服务：需要跨多个领域对象的业务操作，需要用领域服务来完成</li><li>聚合根（Aggregate）：对于那种比较复杂的业务，单一 Entity 无法完全表示它的含义，就需要多个 Entity 共同表示，就放在了一个聚合根中</li><li>业务域：指的是具体的一块业务，比如订单业务域，报价业务域之类的</li><li>充血模式：相比于平时写的比较多的只有 set&#x2F;get 方法的 pojo 类，它还包含了一些行为方法，用于修改自身的状态值</li></ul><p>只要记住，它主要分为战略设计和战术设计。</p><ul><li>战略设计：划分业务域。这里的划分和技术实现完全没有关系，只是业务上的划分。需要业务专家来做决断，这里做的好不好严重影响整个系统架构的质量。（ps：对于架构师来说，业务能力和技术能力一样重要）</li><li>战术设计：具体的设计出一个 Entity，Value Object，Aggregate 等内容</li></ul><h3 id="DDD-有什么优点"><a href="#DDD-有什么优点" class="headerlink" title="DDD 有什么优点"></a>DDD 有什么优点</h3><h4 id="一个-bad-case-的改造"><a href="#一个-bad-case-的改造" class="headerlink" title="一个 bad case 的改造"></a>一个 bad case 的改造</h4><p>一个简单的案例需求如下：<br>用户可以通过银行网页转账给另一个账号，支持跨币种转账。<br>同时因为监管和对账需求，需要记录本次转账活动。<br>拿到这个需求之后，一个开发可能会经历一些技术选型，最终可能拆解需求如下：<br>1、从 MySql 数据库中找到转出和转入的账户，选择用 MyBatis 的 mapper 实现 DAO；<br>2、从 Yahoo（或其他渠道）提供的汇率服务获取转账的汇率信息（底层是 http 开放接口）；<br>3、计算需要转出的金额，确保账户有足够余额，并且没超出每日转账上限；<br>4、实现转入和转出操作，扣除手续费，保存数据库；<br>5、发送 Kafka 审计消息，以便审计和对账用；<br>传统的写法会写出如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TransferController</span> &#123;<br><br>    <span class="hljs-keyword">private</span> TransferService transferService;<br><br>    <span class="hljs-keyword">public</span> Result&lt;Boolean&gt; <span class="hljs-title function_">transfer</span><span class="hljs-params">(String targetAccountNumber, BigDecimal amount, HttpSession session)</span> &#123;<br>        <span class="hljs-type">Long</span> <span class="hljs-variable">userId</span> <span class="hljs-operator">=</span> (Long) session.getAttribute(<span class="hljs-string">&quot;userId&quot;</span>);<br>        <span class="hljs-keyword">return</span> transferService.transfer(userId, targetAccountNumber, amount, <span class="hljs-string">&quot;CNY&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TransferServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TransferService</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">TOPIC_AUDIT_LOG</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;TOPIC_AUDIT_LOG&quot;</span>;<br>    <span class="hljs-keyword">private</span> AccountMapper accountDAO;<br>    <span class="hljs-keyword">private</span> KafkaTemplate&lt;String, String&gt; kafkaTemplate;<br>    <span class="hljs-keyword">private</span> YahooForexService yahooForex;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result&lt;Boolean&gt; <span class="hljs-title function_">transfer</span><span class="hljs-params">(Long sourceUserId, String targetAccountNumber, BigDecimal targetAmount, String targetCurrency)</span> &#123;<br>        <span class="hljs-comment">// 1. 从数据库读取数据，忽略所有校验逻辑如账号是否存在等</span><br>        <span class="hljs-type">AccountDO</span> <span class="hljs-variable">sourceAccountDO</span> <span class="hljs-operator">=</span> accountDAO.selectByUserId(sourceUserId);<br>        <span class="hljs-type">AccountDO</span> <span class="hljs-variable">targetAccountDO</span> <span class="hljs-operator">=</span> accountDAO.selectByAccountNumber(targetAccountNumber);<br><br>        <span class="hljs-comment">// 2. 业务参数校验</span><br>        <span class="hljs-keyword">if</span> (!targetAccountDO.getCurrency().equals(targetCurrency)) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InvalidCurrencyException</span>();<br>        &#125;<br><br>        <span class="hljs-comment">// 3. 获取外部数据，并且包含一定的业务逻辑</span><br>        <span class="hljs-comment">// exchange rate = 1 source currency = X target currency</span><br>        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">exchangeRate</span> <span class="hljs-operator">=</span> BigDecimal.ONE;<br>        <span class="hljs-keyword">if</span> (sourceAccountDO.getCurrency().equals(targetCurrency)) &#123;<br>            exchangeRate = yahooForex.getExchangeRate(sourceAccountDO.getCurrency(), targetCurrency);<br>        &#125;<br>        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">sourceAmount</span> <span class="hljs-operator">=</span> targetAmount.divide(exchangeRate, RoundingMode.DOWN);<br><br>        <span class="hljs-comment">// 4. 业务参数校验</span><br>        <span class="hljs-keyword">if</span> (sourceAccountDO.getAvailable().compareTo(sourceAmount) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InsufficientFundsException</span>();<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (sourceAccountDO.getDailyLimit().compareTo(sourceAmount) &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DailyLimitExceededException</span>();<br>        &#125;<br><br>        <span class="hljs-comment">// 5. 计算新值，并且更新字段</span><br>        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">newSource</span> <span class="hljs-operator">=</span> sourceAccountDO.getAvailable().subtract(sourceAmount);<br>        <span class="hljs-type">BigDecimal</span> <span class="hljs-variable">newTarget</span> <span class="hljs-operator">=</span> targetAccountDO.getAvailable().add(targetAmount);<br>        sourceAccountDO.setAvailable(newSource);<br>        targetAccountDO.setAvailable(newTarget);<br><br>        <span class="hljs-comment">// 6. 更新到数据库</span><br>        accountDAO.update(sourceAccountDO);<br>        accountDAO.update(targetAccountDO);<br><br>        <span class="hljs-comment">// 7. 发送审计消息</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> sourceUserId + <span class="hljs-string">&quot;,&quot;</span> + targetAccountNumber + <span class="hljs-string">&quot;,&quot;</span> + targetAmount + <span class="hljs-string">&quot;,&quot;</span> + targetCurrency;<br>        kafkaTemplate.send(TOPIC_AUDIT_LOG, message);<br><br>        <span class="hljs-keyword">return</span> Result.success(<span class="hljs-literal">true</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>其实从可读性来说，上面的代码是没有什么问题的，注释也很详细。是一段很传统的业务层代码。<br>但是，我们可以看到这一段业务代码中包含了参数校验，数据读写存储，业务计算，调用外部服务，发送消息等操作。这种形式的代码，我们一般叫做“胶水式代码”，有点面向过程编程的意味了。<br>整个代码的调用链路：<br><img src="https://raw.githubusercontent.com/ttoobbyyy/images/master/20240128090602.png"><br>这是按照原来传统三层架构拆解的。<br>“高内聚，低耦合”是对一个好的架构的评价的核心标准。如果对整体架构进行重构的话，就是降低各层之间的依赖。降低依赖的核心解决方案，就是再加一层抽象层！</p><h5 id="抽象存储层"><a href="#抽象存储层" class="headerlink" title="抽象存储层"></a>抽象存储层</h5><p>上面的结构是直接依赖了 mybatis+mysql 的实现，后面如果想更改数据源也很不方便。所以加个抽象层隔离开具体实现。具体做法是：</p><ul><li>新建 Account 实体对象：一个实体（Entity）是拥有 ID 的域对象，除了拥有数据之外，同时拥有行为。Entity 和数据库储存格式无关，因此是需要一个 DO 对象来和数据库映射的</li><li>新建对象储存接口类 AccountRepository：Repository 只负责 Entity 对象的存储和读取，而 Repository 的实现类完成数据库存储的细节。通过加入 Repository 接口，底层的数据库连接可以通过不同的实现类而替换。<br>更改后的架构：<br><img src="https://raw.githubusercontent.com/ttoobbyyy/images/master/20240128095411.png"></li></ul><h5 id="抽象第三方服务"><a href="#抽象第三方服务" class="headerlink" title="抽象第三方服务"></a>抽象第三方服务</h5><p>这里的第三方服务是指“YahooForexService”。虽然这个已经是一个接口了，但是这里其实调用的还是服务提供者的具体实现。如果要隔离服务未来发生变化的可能性，还是要加一层抽象层。这种一般会被称为“<strong>防腐层</strong>”。有了防腐层，外部逻辑再怎么变化，内部都可以尽可能不变！<br>除了隔离变化，防腐层还一般有如下功能：</p><ol><li>适配器：基本功能，将外部数据转为内部数据对象</li><li>缓存：很适合在这里做调用的缓存层</li><li>监控日志：方便后面快速定位是外部系统还是内部系统的问题</li><li>快速降级：这里在这里做兜底逻辑<br>添加后的架构：<br><img src="https://raw.githubusercontent.com/ttoobbyyy/images/master/20240128101246.png"></li></ol><h5 id="抽象中间件"><a href="#抽象中间件" class="headerlink" title="抽象中间件"></a>抽象中间件</h5><p>在对中间件的使用上加一层抽象，主要是中间件的返回值一般都是 byte[ ]结构，我们一般都会有序列化和反序列化的操作，这种操作是不属于业务逻辑的，不应该放在应用层。<br><img src="https://raw.githubusercontent.com/ttoobbyyy/images/master/20240128102120.png"></p><h5 id="封装业务逻辑"><a href="#封装业务逻辑" class="headerlink" title="封装业务逻辑"></a>封装业务逻辑</h5><p>其实重构到现在，我们主要是把系统和外部数据交互的部分都加上了一层抽象层。剩余的就是一下业务规则计算了，这些是属于纯内存操作。而这些纯内存操作正是整个业务系统最核心的地方。也正是业务域的关键。<br>一般封装业务逻辑，我们第一步是将业务逻辑抽象概括出一些核心的 Entity 或者 Value Object。第二步是判断业务逻辑中有没有一些跨 Entity 的操作，如果有的话，就要新增“Domain Service”，用于处理多对象逻辑。<br>这里的话，就新增了 Account（Entity），ExchangeRate（Value Object） ，AccountTransferService （Domain Service）<br>最后就变成：<br><img src="https://raw.githubusercontent.com/ttoobbyyy/images/master/20240128103548.png"></p><h5 id="改造后效果"><a href="#改造后效果" class="headerlink" title="改造后效果"></a>改造后效果</h5><p>从代码上来看，其实区别不是很大：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">TransferServiceImplNew</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">TransferService</span> &#123;<br><br>    <span class="hljs-keyword">private</span> AccountRepository accountRepository;<br>    <span class="hljs-keyword">private</span> AuditMessageProducer auditMessageProducer;<br>    <span class="hljs-keyword">private</span> ExchangeRateService exchangeRateService;<br>    <span class="hljs-keyword">private</span> AccountTransferService accountTransferService;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Result&lt;Boolean&gt; <span class="hljs-title function_">transfer</span><span class="hljs-params">(Long sourceUserId, String targetAccountNumber, BigDecimal targetAmount, String targetCurrency)</span> &#123;<br>        <span class="hljs-comment">// 参数校验</span><br>        <span class="hljs-type">Money</span> <span class="hljs-variable">targetMoney</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Money</span>(targetAmount, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Currency</span>(targetCurrency));<br><br>        <span class="hljs-comment">// 读数据</span><br>        <span class="hljs-type">Account</span> <span class="hljs-variable">sourceAccount</span> <span class="hljs-operator">=</span> accountRepository.find(<span class="hljs-keyword">new</span> <span class="hljs-title class_">UserId</span>(sourceUserId));<br>        <span class="hljs-type">Account</span> <span class="hljs-variable">targetAccount</span> <span class="hljs-operator">=</span> accountRepository.find(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AccountNumber</span>(targetAccountNumber));<br>        <span class="hljs-type">ExchangeRate</span> <span class="hljs-variable">exchangeRate</span> <span class="hljs-operator">=</span> exchangeRateService.getExchangeRate(sourceAccount.getCurrency(), targetMoney.getCurrency());<br><br>        <span class="hljs-comment">// 业务逻辑</span><br>        accountTransferService.transfer(sourceAccount, targetAccount, targetMoney, exchangeRate);<br><br>        <span class="hljs-comment">// 保存数据</span><br>        accountRepository.save(sourceAccount);<br>        accountRepository.save(targetAccount);<br><br>        <span class="hljs-comment">// 发送审计消息</span><br>        <span class="hljs-type">AuditMessage</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AuditMessage</span>(sourceAccount, targetAccount, targetMoney);<br>        auditMessageProducer.send(message);<br><br>        <span class="hljs-keyword">return</span> Result.success(<span class="hljs-literal">true</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>而它的业务分层则按照 DDD 的方式来看：<br><img src="https://raw.githubusercontent.com/ttoobbyyy/images/master/20240128103814.png"></p><ul><li>领域层纯粹是内存操作，不依赖任何外部依赖</li><li>应用层则依赖抽象，而不依赖实现，有效隔离了变化。而应用层做的核心工作就是拼装逻辑</li><li>其实对于 DDD 的四层架构来看，实际情况最容易发生变化的是领域层。业务规则最容易变化，而其他的基础设施层，接口层一般来说都不会做很大变动。这也符合<strong>领域驱动设计</strong>的思想。</li></ul><h3 id="应用到实际工作中"><a href="#应用到实际工作中" class="headerlink" title="应用到实际工作中"></a>应用到实际工作中</h3><p>其实主要是有一些启发吧。DDD 本质是一种架构思想，为拆分微服务提供了指导方针。我阅读的博客大部分是一些偏向于能落地的，所以我对 DDD 的理解可能会有一些偏差。那几本著名的 DDD 的技术书都没有研究过。<br>不过，基于我目前的知识水平，还是能收获很多的。</p><ol><li>业务开发的核心难点在于业务的复杂度，而业务的复杂度其实可以通过一些良好的架构设计来减少一些。后续的工作时，除了技术水平，业务水平也得一起练习。</li><li><strong>高内聚，低耦合</strong>。这句话很重要，是架构设计的核心追求，我感觉我现在可能都理解的不够深刻。需要在平时的工作中多思考，如何做到这个</li><li>充血模型在一定场合可以用用，不过也不能说贫血模型就不合适</li><li>DDD 不是瑞士军刀，不是每一个场景都需要像 DDD 这样，做这么多的抽象层的。对于一些工具类的需求，三层架构可能会带来更好的可读性。</li></ol><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://zhuanlan.zhihu.com/p/351162895">DDD领域驱动设计总结 - 知乎 (zhihu.com)</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzAxNDEwNjk5OQ==&chksm=83953cc4b4e2b5d2bd4426e0d2103f2e95715b682f3b7ff333dbb123eaa79d3e5ad24f64beac&idx=1&mid=2650404060&scene=21&sn=cacf40d19528f6c2d9fd165151d6e8b4#wechat_redirect">阿里技术专家详解DDD系列 第二弹 - 应用架构 (qq.com)</a></p>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>架构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>logback源码分析</title>
    <link href="/2024/01/06/logback%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <url>/2024/01/06/logback%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h3 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h3><p>最近排查一个线上异常，发现起因是日志打印不完整，使用的日志框架正是 logback，在排查问题的过程中深入学习了相关源码，虽然最后没有得到可靠的结论，排查过程中没有发现有对单条日志大小进行限制的配置，我认为是数据落盘的时候丢失了一部分。</p><h3 id="slf4j"><a href="#slf4j" class="headerlink" title="slf4j"></a>slf4j</h3><p>Java 的日志框架常用的有 log4j、logback、jul(common-log)以及 log4j2。为了实现不同日志框架之间的无缝切换，Ceki Gülcü 大神开发了 slf4j(Simple Logging Facade for Java) 。slf4j 是众多日志框架抽象的门面接口，有了 slf4j 想要切换日志实现，只需要把对应日志 jar 替换和添加对应的适配器。<br><img src="https://raw.githubusercontent.com/ttoobbyyy/images/master/20240107192051.png"></p><h3 id="抽象概念"><a href="#抽象概念" class="headerlink" title="抽象概念"></a>抽象概念</h3><p>logback 日志框架提出的抽象概念比较少，易于理解。只有 logger 和 appender，而且这两个概念还可以通过配置文件来理解其作用。</p><blockquote><p>Java 对抽象设计的要求会比较高一些，对于一个框架来说，理解了它核心抽象，那基本就理解了它的核心实现。对于我们学习源码来说，分析清楚作者为什么要设计这个抽象，为什么不能再细分？也是一个不错的思考点。</p></blockquote><h4 id="logger"><a href="#logger" class="headerlink" title="logger"></a>logger</h4><p>主要功能有两个：</p><ul><li>谁来打印日志，也就是日志的数据源来自哪里</li><li>控制打印的日志级别<br>再看看配置文件中是如何配置它的：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;promotion_middle_result_logger&quot;</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">level</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;INFO&quot;</span> /&gt;</span>  %% 配置日志级别 %%<br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;asyncPromotionMidResulAppender&quot;</span>/&gt;</span>  %% 绑定appender %%<br><span class="hljs-tag">&lt;/<span class="hljs-name">logger</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;WARN&quot;</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;consoleAsync&quot;</span>/&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br></code></pre></td></tr></table></figure>ch.qos.logback.classic.Logger 的所有属性如下：<br><img src="https://raw.githubusercontent.com/ttoobbyyy/images/master/20240107192117.png"></li></ul><p>需要注意的有三点：</p><ol><li><code>parent</code> 和 <code>childrenList</code> 维护了一个 Logger 的继承树，继承是依据 name 来的，以 name 中的“.”划分层级。所有继承树的根节点是 <code>Root</code>。它的作用是子节点可以继承父节点的配置，日志级别，appender 等</li><li><code>loggerContext</code> 用于生成 logger，一般来说，context 都会包含整个处理逻辑最重要的信息</li><li><code>AppenderAttachableImpl</code> 是指配置的 appender 信息</li></ol><h4 id="Appender"><a href="#Appender" class="headerlink" title="Appender"></a>Appender</h4><p>主要功能是指定日志输出到哪里，但也有一些附加功能：</p><ol><li>指定日志输出位置：console、file、数据库等</li><li>encoder：指定日志打印格式</li><li>还有一些额外配置，如文件大小，文件名格式等<br>看配置信息：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.RollingFileAppender&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;promotionMidResulAppender&quot;</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">file</span>&gt;</span>$&#123;LOG_HOME&#125;/promotion_middle_result.log<span class="hljs-tag">&lt;/<span class="hljs-name">file</span>&gt;</span>  <br>    <span class="hljs-comment">&lt;!--文件滚动保存策略--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">rollingPolicy</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.rolling.TimeBasedRollingPolicy&quot;</span>&gt;</span> <br>        <span class="hljs-tag">&lt;<span class="hljs-name">fileNamePattern</span>&gt;</span>$&#123;LOG_HOME&#125;/promotion_middle_result.log.%d&#123;yyyy-MM-dd-HH&#125;.gz<span class="hljs-tag">&lt;/<span class="hljs-name">fileNamePattern</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">maxHistory</span>&gt;</span>10<span class="hljs-tag">&lt;/<span class="hljs-name">maxHistory</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">rollingPolicy</span>&gt;</span>  <br>    <span class="hljs-comment">&lt;!--日志输出格式--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span>  <br>        <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>[%d&#123;yyyy-MM-dd HH:mm:ss&#125;] %m%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span>  <br><br><span class="hljs-comment">&lt;!--异步输出的配置--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">appender</span>  <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;asyncPromotionMidResulAppender&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.classic.AsyncAppender&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;promotionMidResulAppender&quot;</span>/&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">queueSize</span>&gt;</span>1500<span class="hljs-tag">&lt;/<span class="hljs-name">queueSize</span>&gt;</span>  <br>    <span class="hljs-tag">&lt;<span class="hljs-name">discardingThreshold</span>&gt;</span>0<span class="hljs-tag">&lt;/<span class="hljs-name">discardingThreshold</span>&gt;</span>  <br><span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h3><h4 id="LogContext-初始化"><a href="#LogContext-初始化" class="headerlink" title="LogContext 初始化"></a>LogContext 初始化</h4><p>步骤 1：<br>logContext 的初始化是从获取 logger 开始的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">log</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(<span class="hljs-string">&quot;promotion_middle_result.logger&quot;</span>);<br></code></pre></td></tr></table></figure><p>步骤 2：<br>org.slf4j.LoggerFactory # getLogger (java.lang.String)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Logger <span class="hljs-title function_">getLogger</span><span class="hljs-params">(String name)</span> &#123;  <br>  <span class="hljs-type">ILoggerFactory</span> <span class="hljs-variable">iLoggerFactory</span> <span class="hljs-operator">=</span> getILoggerFactory(); <span class="hljs-comment">// logContext初始化</span><br>  <span class="hljs-keyword">return</span> iLoggerFactory.getLogger(name);  <br>&#125;<br></code></pre></td></tr></table></figure><p>步骤 3：<br>org.slf4j.LoggerFactory # getILoggerFactory</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ILoggerFactory <span class="hljs-title function_">getILoggerFactory</span><span class="hljs-params">()</span> &#123;  <br>  <span class="hljs-comment">// 由状态字段来控制是否初始化好了</span><br>  <span class="hljs-keyword">if</span> (INITIALIZATION_STATE == UNINITIALIZED) &#123;  <br>    INITIALIZATION_STATE = ONGOING_INITIALIZATION;  <br>    performInitialization();  <br>  &#125;  <br>  <span class="hljs-keyword">switch</span> (INITIALIZATION_STATE) &#123;  <br>    <span class="hljs-keyword">case</span> SUCCESSFUL_INITIALIZATION:  <br>      <span class="hljs-keyword">return</span> StaticLoggerBinder.getSingleton().getLoggerFactory();  <br>    <span class="hljs-keyword">case</span> NOP_FALLBACK_INITIALIZATION:  <br>      <span class="hljs-keyword">return</span> NOP_FALLBACK_FACTORY;  <br>    <span class="hljs-keyword">case</span> FAILED_INITIALIZATION:  <br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(UNSUCCESSFUL_INIT_MSG);  <br>    <span class="hljs-keyword">case</span> ONGOING_INITIALIZATION:  <br>      <span class="hljs-comment">// support re-entrant behavior.  </span><br>      <span class="hljs-comment">// See also http://bugzilla.slf4j.org/show_bug.cgi?id=106      </span><br>      <span class="hljs-keyword">return</span> TEMP_FACTORY;  <br>  &#125;<br>  <span class="hljs-comment">// 这种写法可以借鉴</span><br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Unreachable code&quot;</span>);  <br>&#125;<br></code></pre></td></tr></table></figure><p>这里的 <code>INITIALIZATION_STATE</code> 字段没有使用 volatile 修饰，因为对这个值的读写过程并没有并发安全问题。后面会看到 logContext 的初始化是借助类加载过程初始化的，只会执行一次</p><p>步骤 4：<br>org.slf4j.LoggerFactory # performInitialization</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">performInitialization</span><span class="hljs-params">()</span> &#123;<br>  <span class="hljs-comment">// 开始要绑定日志框架了，slf4j毕竟就是一个门面框架</span><br>  bind();  <br>  <span class="hljs-keyword">if</span> (INITIALIZATION_STATE == SUCCESSFUL_INITIALIZATION) &#123;  <br>    versionSanityCheck();  <br>  &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>步骤 5：<br>org.slf4j.LoggerFactory # bind</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">bind</span><span class="hljs-params">()</span> &#123;  <br>  <span class="hljs-keyword">try</span> &#123;  <br>    <span class="hljs-comment">// 找到所有可以绑定的日志框架，依据是org/slf4j/impl/StaticLoggerBinder.class类</span><br>    <span class="hljs-type">Set</span> <span class="hljs-variable">staticLoggerBinderPathSet</span> <span class="hljs-operator">=</span> findPossibleStaticLoggerBinderPathSet();<br>    <span class="hljs-comment">// 提示有多个日志框架可用</span><br>    reportMultipleBindingAmbiguity(staticLoggerBinderPathSet);  <br>    <span class="hljs-comment">// 这里其实是为了将StaticLoggerBinder加载入内存</span><br>    StaticLoggerBinder.getSingleton();  <br>    INITIALIZATION_STATE = SUCCESSFUL_INITIALIZATION;  <br>    reportActualBinding(staticLoggerBinderPathSet);  <br>    emitSubstituteLoggerWarning();  <br>  &#125; <span class="hljs-keyword">catch</span> (NoClassDefFoundError ncde) &#123;  <br>    ...<br>  &#125; <span class="hljs-keyword">catch</span> (java.lang.NoSuchMethodError nsme) &#123;  <br>    ...<br>  &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;  <br>    failedBinding(e);  <br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;Unexpected initialization failure&quot;</span>, e);  <br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里的逻辑断层了，可能会无法理解，该如何初始化 logContext（ps：其中一个重要步骤是解析 <code>logback.xml</code>），一般遇到这种情况，只能根据前一个步骤提示的 org&#x2F;slf4j&#x2F;impl&#x2F;StaticLoggerBinder.class 来找线索了</p><blockquote><p>这里还有个感受是，源码注释并不多，但是并不妨碍理解，函数名命名的很讲究。不过我们平时写业务代码时，还是最好加上中文注释，方便后面人全局搜索</p></blockquote><p>步骤 6：<br>org.slf4j.impl.StaticLoggerBinder # init</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">()</span> &#123;  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-keyword">try</span> &#123;  <br>    <span class="hljs-comment">// 配置文件在这里加载</span><br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">ContextInitializer</span>(defaultLoggerContext).autoConfig();  <br>        &#125; <span class="hljs-keyword">catch</span> (JoranException je) &#123;  <br>            Util.report(<span class="hljs-string">&quot;Failed to auto configure default logger context&quot;</span>, je);  <br>        &#125;  <br>        <span class="hljs-comment">// logback-292</span><br>        <span class="hljs-keyword">if</span> (!StatusUtil.contextHasStatusListener(defaultLoggerContext)) &#123;  <br>            StatusPrinter.printInCaseOfErrorsOrWarnings(defaultLoggerContext);  <br>        &#125;  <br>        contextSelectorBinder.init(defaultLoggerContext, KEY);  <br>        initialized = <span class="hljs-literal">true</span>;  <br>    &#125; <span class="hljs-keyword">catch</span> (Exception t) &#123; <span class="hljs-comment">// see LOGBACK-1159  </span><br>        Util.report(<span class="hljs-string">&quot;Failed to instantiate [&quot;</span> + LoggerContext.class.getName() + <span class="hljs-string">&quot;]&quot;</span>, t);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>其他细节就不看了，这里解析了配置文件，并初始化了 <code>logContext</code> 对象</p><h4 id="日志打印"><a href="#日志打印" class="headerlink" title="日志打印"></a>日志打印</h4><p>日志框架会将每一条日志当作了一个事件来处理。如果是同步打印，那么就是直接写入文件。如果是异步打印，则会用一个队列来收集事件，最后由日志线程来遍历队列写入文件。<br>这里我将分析异步过程。<br>步骤 1：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">filterAndLog_0_Or3Plus</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String localFQCN, <span class="hljs-keyword">final</span> Marker marker, <span class="hljs-keyword">final</span> Level level, <span class="hljs-keyword">final</span> String msg, <span class="hljs-keyword">final</span> Object[] params,  </span><br><span class="hljs-params">                <span class="hljs-keyword">final</span> Throwable t)</span> &#123;  <br>  <br>    <span class="hljs-keyword">final</span> <span class="hljs-type">FilterReply</span> <span class="hljs-variable">decision</span> <span class="hljs-operator">=</span> loggerContext.getTurboFilterChainDecision_0_3OrMore(marker, <span class="hljs-built_in">this</span>, level, msg, params, t);  <br>   <span class="hljs-comment">// 判断日志级别</span><br>    <span class="hljs-keyword">if</span> (decision == FilterReply.NEUTRAL) &#123;  <br>        <span class="hljs-keyword">if</span> (effectiveLevelInt &gt; level.levelInt) &#123;  <br>            <span class="hljs-keyword">return</span>;  <br>        &#125;  <br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (decision == FilterReply.DENY) &#123;  <br>        <span class="hljs-keyword">return</span>;  <br>    &#125;<br>    <span class="hljs-comment">// 构建LoggingEvent对象</span><br>    buildLoggingEventAndAppend(localFQCN, marker, level, msg, params, t);  <br>&#125;<br></code></pre></td></tr></table></figure><p>步骤 2：<br>ch.qos.logback.classic.Logger # buildLoggingEventAndAppend</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">buildLoggingEventAndAppend</span><span class="hljs-params">(<span class="hljs-keyword">final</span> String localFQCN, <span class="hljs-keyword">final</span> Marker marker, <span class="hljs-keyword">final</span> Level level, <span class="hljs-keyword">final</span> String msg, <span class="hljs-keyword">final</span> Object[] params,  </span><br><span class="hljs-params">                <span class="hljs-keyword">final</span> Throwable t)</span> &#123;  <br>    <span class="hljs-comment">// 这个对象包含的信息很多</span><br>    <span class="hljs-type">LoggingEvent</span> <span class="hljs-variable">le</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">LoggingEvent</span>(localFQCN, <span class="hljs-built_in">this</span>, level, msg, t, params);  <br>    le.setMarker(marker);  <br>    callAppenders(le);  <br>&#125;<br></code></pre></td></tr></table></figure><p>步骤 3：<br>ch.qos.logback.classic.Logger # callAppenders</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">callAppenders</span><span class="hljs-params">(ILoggingEvent event)</span> &#123;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">writes</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br>    <span class="hljs-comment">// 这里遍历了logger继承树</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">Logger</span> <span class="hljs-variable">l</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>; l != <span class="hljs-literal">null</span>; l = l.parent) &#123;  <br>    <span class="hljs-comment">// 遍历这个logger绑定的appenders</span><br>        writes += l.appendLoopOnAppenders(event); <br>        <span class="hljs-keyword">if</span> (!l.additive) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;  <br>    <span class="hljs-comment">// No appenders in hierarchy  </span><br>    <span class="hljs-keyword">if</span> (writes == <span class="hljs-number">0</span>) &#123;  <br>        loggerContext.noAppenderDefinedWarning(<span class="hljs-built_in">this</span>);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>步骤 4：<br>ch.qos.logback.core.spi.AppenderAttachableImpl # appendLoopOnAppenders</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">appendLoopOnAppenders</span><span class="hljs-params">(E e)</span> &#123;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">final</span> Appender&lt;E&gt;[] appenderArray = appenderList.asTypedArray();  <br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> appenderArray.length;  <br>    <span class="hljs-comment">// 遍历appender</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++) &#123;  <br>        appenderArray[i].doAppend(e);  <br>        size++;  <br>    &#125;<br>    <span class="hljs-keyword">return</span> size;  <br>&#125;<br></code></pre></td></tr></table></figure><p>步骤 5：<br>ch.qos.logback.core.AsyncAppenderBase # append</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">append</span><span class="hljs-params">(E eventObject)</span> &#123;  <br>    <span class="hljs-keyword">if</span> (isQueueBelowDiscardingThreshold() &amp;&amp; isDiscardable(eventObject)) &#123;  <br>        <span class="hljs-keyword">return</span>;  <br>    &#125;  <br>    preprocess(eventObject);  <br>    put(eventObject);  <br>&#125;<br></code></pre></td></tr></table></figure><p>步骤 6：<br>ch.qos.logback.core.AsyncAppenderBase # put</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">put</span><span class="hljs-params">(E eventObject)</span> &#123;  <br>    <span class="hljs-keyword">if</span> (neverBlock) &#123;<br>    <span class="hljs-comment">// 队列满了就直接丢弃</span><br>        blockingQueue.offer(eventObject);  <br>    &#125; <span class="hljs-keyword">else</span> &#123;  <br>    <span class="hljs-comment">// 这里会阻塞一下</span><br>        putUninterruptibly(eventObject);  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>到这里业务线程就执行完毕了，主要是将 <code>loggingEvent</code> 放入队列。接下来视角切换到日志线程。</p><p>步骤 7：<br>ch.qos.logback.core.AsyncAppenderBase.Worker # run</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;  <br>    AsyncAppenderBase&lt;E&gt; parent = AsyncAppenderBase.<span class="hljs-built_in">this</span>;  <br>    AppenderAttachableImpl&lt;E&gt; aai = parent.aai;  <br>  <br>    <span class="hljs-comment">// loop while the parent is started  </span><br>    <span class="hljs-keyword">while</span> (parent.isStarted()) &#123;  <br>        <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-comment">// 遍历队列元素</span><br>            <span class="hljs-type">E</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> parent.blockingQueue.take();  <br>            aai.appendLoopOnAppenders(e);  <br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException ie) &#123;  <br>            <span class="hljs-keyword">break</span>;  <br>        &#125;  <br>    &#125;  <br>  <br>    addInfo(<span class="hljs-string">&quot;Worker thread will flush remaining events before exiting. &quot;</span>);  <br>  <br>    <span class="hljs-keyword">for</span> (E e : parent.blockingQueue) &#123;  <br>        aai.appendLoopOnAppenders(e);  <br>        parent.blockingQueue.remove(e);  <br>    &#125;  <br>  <br>    aai.detachAndStopAllAppenders();  <br>&#125;<br></code></pre></td></tr></table></figure><p>步骤 8：<br>ch.qos.logback.core.spi.AppenderAttachableImpl # appendLoopOnAppenders</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">appendLoopOnAppenders</span><span class="hljs-params">(E e)</span> &#123;  <br>    <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">final</span> Appender&lt;E&gt;[] appenderArray = appenderList.asTypedArray();  <br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">len</span> <span class="hljs-operator">=</span> appenderArray.length;  <br>    <span class="hljs-comment">// 还是需要遍历appender</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; len; i++) &#123;  <br>        appenderArray[i].doAppend(e);  <br>        size++;  <br>    &#125;  <br>    <span class="hljs-keyword">return</span> size;  <br>&#125;<br></code></pre></td></tr></table></figure><p>步骤 9：<br>ch.qos.logback.core.OutputStreamAppender # subAppend</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">subAppend</span><span class="hljs-params">(E event)</span> &#123;  <br>    <span class="hljs-keyword">if</span> (!isStarted()) &#123;  <br>        <span class="hljs-keyword">return</span>;  <br>    &#125;  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        <span class="hljs-comment">// this step avoids LBCLASSIC-139  </span><br>        <span class="hljs-keyword">if</span> (event <span class="hljs-keyword">instanceof</span> DeferredProcessingAware) &#123;  <br>            ((DeferredProcessingAware) event).prepareForDeferredProcessing();  <br>        &#125;  <br>        <span class="hljs-comment">// the synchronization prevents the OutputStream from being closed while we  </span><br>        <span class="hljs-comment">// are writing. It also prevents multiple threads from entering the same        // converter. Converters assume that they are in a synchronized block.        // lock.lock();  </span><br>        <span class="hljs-comment">// 日志格式化输出在这里</span><br>        <span class="hljs-type">byte</span>[] byteArray = <span class="hljs-built_in">this</span>.encoder.encode(event);  <br>        <span class="hljs-comment">// 这里就直接写入文件了</span><br>        writeBytes(byteArray);  <br>  <br>    &#125; <span class="hljs-keyword">catch</span> (IOException ioe) &#123;  <br>        <span class="hljs-comment">// as soon as an exception occurs, move to non-started state  </span><br>        <span class="hljs-comment">// and add a single ErrorStatus to the SM.        this.started = false;  </span><br>        addStatus(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ErrorStatus</span>(<span class="hljs-string">&quot;IO failure in appender&quot;</span>, <span class="hljs-built_in">this</span>, ioe));  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>本文从 <code>logContext初始化</code> 和 <code>日志打印流程</code> 两个角度分析 logback 的源码。整体流程并不复杂，可以自己去多点几次。<br>个人认为看源码是需要学习到一些东西的，比如设计模式，代码格式，函数命名等之类的。</p>]]></content>
    
    
    <categories>
      
      <category>工具框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>日志</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库事务--隔离性与MVCC（3）</title>
    <link href="/2023/12/26/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1--%E9%9A%94%E7%A6%BB%E6%80%A7%E4%B8%8EMVCC%EF%BC%883%EF%BC%89/"/>
    <url>/2023/12/26/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1--%E9%9A%94%E7%A6%BB%E6%80%A7%E4%B8%8EMVCC%EF%BC%883%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>并发是程序最为复杂的场景之一，在数据库领域，做好隔离就是为了解决并发的问题。然而不同于我们在业务场景中处理并发问题，直接加锁就好了。对于数据库，还得考虑整体吞吐量，不能用锁“一棍子打死”。于是就存在诸如<strong>读锁，写锁，意向锁，范围锁</strong>等一系列锁的类型。而且锁的范围也得考虑，锁表，还是只锁对应的行。这些都是需要考虑的，同时，除了锁，还会存在并发程度高的解决方案，如<strong>MVCC(多版本并发控制协议)</strong> 等<br>锁+MVCC 就是数据库解决并发问题的方案。</p><h3 id="一句话术语解释"><a href="#一句话术语解释" class="headerlink" title="一句话术语解释"></a>一句话术语解释</h3><h4 id="读锁（共享锁）"><a href="#读锁（共享锁）" class="headerlink" title="读锁（共享锁）"></a>读锁（共享锁）</h4><p>允许多个线程同时进入临界区。一般用于读取场景，不修改数据。</p><h4 id="写锁（排他锁）"><a href="#写锁（排他锁）" class="headerlink" title="写锁（排他锁）"></a>写锁（排他锁）</h4><p>一次只允许一个线程进入临界区，一般用于修改场景。</p><blockquote><p>读写场景分开，是因为对于数据库来说，一般是读场景远大于写场景。如果两者频率差不多，这么区分的意义不大。</p></blockquote><h4 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h4><p>在获取数据表的共享&#x2F;排他锁之前，需要先获取数据表对应的共享&#x2F;排他意向锁，表明要对数据表进行加锁了。这里的锁是表级锁，不是行级锁。<br>解决的问题是：在对数据表加表级共享&#x2F;排他锁之前，需要确保数据表中无行级锁。如果要遍历那速度太慢了，就有了<strong>意向锁</strong>。意向锁会和表级共享锁和表级排他锁互斥，和行级锁都兼容。<br>意向锁的设计还是很不错的，可以借鉴。</p><h4 id="范围锁（gap-锁，next-key-锁）"><a href="#范围锁（gap-锁，next-key-锁）" class="headerlink" title="范围锁（gap 锁，next-key 锁）"></a>范围锁（gap 锁，next-key 锁）</h4><p>范围锁指的是在查找或者更新一定范围的数据时，为了避免幻读现象，加上了锁，使得这个范围中的数据不可以被新增，修改，删除。</p><h4 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h4><p>多版本控制协议，本质上是保留了一行数据的多个历史版本。不同的事务根据一定的可见性规则，会看到不同的历史版本数据。从而将数据隔离开来。<br>本质是为了处理读写冲突。</p><h4 id="快照读-VS-当前读"><a href="#快照读-VS-当前读" class="headerlink" title="快照读 VS 当前读"></a>快照读 VS 当前读</h4><ul><li>快照读：指的是利用 MVCC 读取的历史数据</li><li>当前读：指的是通过加锁的方式，读取数据库的最新数据</li></ul><h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><p>以下四种隔离级别，隔离性越来越高，并行度越来越低。<br>在理解下面的隔离级别时，可以自行代入有两个事务在同时间执行。</p><h4 id="读未提交（Read-uncommitted）"><a href="#读未提交（Read-uncommitted）" class="headerlink" title="读未提交（Read uncommitted）"></a>读未提交（Read uncommitted）</h4><p>隔离性最低。<br>读到另一个事务未提交的数据。也就是另一个事务没有提交的数据都对本事务可见。相当于没有任何隔离措施。这种现象也叫做<strong>脏读</strong>。</p><h4 id="读已提交（Read-committed）"><a href="#读已提交（Read-committed）" class="headerlink" title="读已提交（Read committed）"></a>读已提交（Read committed）</h4><p>读取到另一个事务提交的数据。<br>会产生<strong>不可重复读问题</strong>，指的是同一个事务，两次读取同一行记录，可能读取到的结果不一样。<br>解决了脏读问题。解决方式是使用了 MVCC，在事务执行期间，每次 select 查询数据，都会根据可见性规则查看可见的历史数据，对于那种未提交的数据是看不到的。</p><h4 id="可重复读（Repeatable-read）"><a href="#可重复读（Repeatable-read）" class="headerlink" title="可重复读（Repeatable read）"></a>可重复读（Repeatable read）</h4><p>多次读取同一行数据，数据都是一致的。<br>也就是解决了<strong>不可重复读问题</strong>，解决方式也是使用了 MVCC，在事务执行期间，事务第一次 select 查询数据，会根据可见性规则查看一份可见数据，后面再次查询还是使用同一份数据。于是每次查询数据都是一致的。<br>会产生<strong>幻读</strong>问题。幻读问题一般理解是查找一定范围数据，两次查找的结果不一致。举两个例子。<br>案例一：</p><blockquote><p>查找 id 1-50 的数据，第一次读取到 30 条数据，而第二次读取到 31 条数据。<br>这种 case，分为两种情况。<br>快照读：通过 MVCC 处理，利用 MVCC 的可见性规则，可以让读取的数据只有 30 条。<br>当前读：MySQL 通过<strong>gap 锁</strong>解决了这个问题，给这个范围内的数据加上行锁和间隙锁。</p></blockquote><p>案例二：</p><blockquote><p>查找 id 为 1 的数据，第一次没有查到，第二次也没有查到，但是想要插入的时候，报错了。被其他事务抢先插入了。<br>这种 case 也属于幻读。而且在可重复读的隔离级别下是处理不了的</p></blockquote><h4 id="串行化（Serializable）"><a href="#串行化（Serializable）" class="headerlink" title="串行化（Serializable）"></a>串行化（Serializable）</h4><p>隔离性最高。<br>读请求加读锁，写请求加写锁。<br>读读不互斥，读写互斥，写写互斥。</p><h4 id="如何选择隔离级别"><a href="#如何选择隔离级别" class="headerlink" title="如何选择隔离级别"></a>如何选择隔离级别</h4><p>这是需要综合考虑的。</p><ol><li>数据一致性要求，这里的数据一致性，其实更多是指利用数据库来处理线程安全问题。除了最后一个串行化，其他的都或多或少存在问题。对于平时说的数据一致性，指的是业务一致性，利用消息队列，分布式事务，重试等手段来保障最后业务一致性即可。</li><li>并发程度，如果业务场景并不是并发的，隔离级别就不重要了</li><li>性能要求，串行化的隔离级别性能最低，其他隔离级别性能都还好。</li><li>最佳实践：对于 MySQL 来说，采取默认的可重复读隔离级别就足以应付大部分场景了，性能也足够。</li></ol><h3 id="MVCC-1"><a href="#MVCC-1" class="headerlink" title="MVCC"></a>MVCC</h3><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><p>这个方案在很多数据库都有相关实现，使用它主要是为了处理读-写冲突。</p><h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>主要实现方案是维护数据的历史版本链。</p><h5 id="版本链"><a href="#版本链" class="headerlink" title="版本链"></a>版本链</h5><p>数据表中的每行数据，都含有几个隐藏字段，分别是：</p><ul><li>db_trx_id：最近操作这行记录的事务 ID</li><li>db_roll_pointer：指向这行记录的上一个版本</li><li>db_row_id：隐含的自增 ID，如果数据表没有主键，InnoDB 会使用它来生成聚簇索引</li></ul><h5 id="undo-log"><a href="#undo-log" class="headerlink" title="undo log"></a>undo log</h5><p>可见<a href="https://ttoobbyyy.github.io/2023/11/17/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1--%E5%8E%9F%E5%AD%90%E6%80%A7%E5%92%8C%E6%8C%81%E4%B9%85%E6%80%A7%E5%8E%9F%E7%90%86(2)/">数据库事务–原子性和持久性原理(2)</a></p><h5 id="Read-View（可见性规则）"><a href="#Read-View（可见性规则）" class="headerlink" title="Read View（可见性规则）"></a>Read View（可见性规则）</h5><p>每次判断某行记录是否可以展示的时候，都会生成一个 readView。它有 4 个主要属性：</p><ul><li><code>trx_ids</code>: 当前系统活跃(<code>未提交</code>)事务版本号集合。</li><li><code>low_limit_id</code>: 创建当前read view 时“当前系统<code>最大事务版本号</code>+1”。</li><li><code>up_limit_id</code>: 创建当前read view 时“系统正处于活跃事务<code>最小版本号</code>”</li><li><code>creator_trx_id</code>: 创建当前read view的事务版本号；<br>而判断数据是否可见，则有以下判断条件：</li><li><code>db_trx_id</code> &lt; <code>up_limit_id</code> || <code>db_trx_id</code> &#x3D;&#x3D; <code>creator_trx_id</code>（显示）<br>  如果数据事务ID小于read view中的<code>最小活跃事务ID</code>，则可以肯定该数据是在<code>当前事务启之前</code>就已经<code>存在</code>了的,所以可以<code>显示</code>。<br>  或者数据的<code>事务ID</code>等于<code>creator_trx_id</code> ，那么说明这个数据就是当前事务<code>自己生成的</code>，自己生成的数据自己当然能看见，所以这种情况下此数据也是可以<code>显示</code>的。</li><li><code>db_trx_id</code> &gt;&#x3D; <code>low_limit_id</code>（不显示）<br>  如果数据事务ID大于read view 中的当前系统的<code>最大事务ID</code>，则说明该数据是在当前read view 创建<code>之后才产生</code>的，所以数据<code>不显示</code>。如果小于则进入下一个判断</li><li><code>db_trx_id</code>是否在<code>活跃事务</code>（trx_ids）中<ul><li><code>不存在</code>：则说明read view产生的时候事务<code>已经commit</code>了，这种情况数据则可以<code>显示</code>。</li><li><code>已存在</code>：则代表Read View生成时刻，事务还在活跃，还没有Commit，修改的数据，当前事务也是看不见的。</li></ul></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>数据库的隔离性在平时业务开发中不怎么会涉及，但读写锁，MVCC 等并发解决方案还是值得学习的</p><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a href="https://juejin.cn/post/6844903666332368909">详解 MySql InnoDB 中意向锁的作用 - 掘金 (juejin.cn)</a><br><a href="https://juejin.cn/post/6871046354018238472">全网最全一篇数据库MVCC详解，不全你打我 - 掘金 (juejin.cn)</a></p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>事务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库事务--原子性和持久性原理(2)</title>
    <link href="/2023/11/17/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1--%E5%8E%9F%E5%AD%90%E6%80%A7%E5%92%8C%E6%8C%81%E4%B9%85%E6%80%A7%E5%8E%9F%E7%90%86(2)/"/>
    <url>/2023/11/17/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1--%E5%8E%9F%E5%AD%90%E6%80%A7%E5%92%8C%E6%8C%81%E4%B9%85%E6%80%A7%E5%8E%9F%E7%90%86(2)/</url>
    
    <content type="html"><![CDATA[<h3 id="例子引入"><a href="#例子引入" class="headerlink" title="例子引入"></a>例子引入</h3><p>对于原子性和持久性的解释可以看<a href="https://ttoobbyyy.github.io/2023/10/22/MySQL%E4%BA%8B%E5%8A%A1%E7%B3%BB%E5%88%97--%E4%BB%8B%E7%BB%8D/">上一篇文章</a>。<br>下面是一个简单的例子：<br>用户在一个网站上注册了信息，这个功能最终需要保存用户信息到数据库上。假如数据库没有任何保护措施。在程序将数据从内存搬运到对应磁盘位置时，断电了（crash），这就会产生脏数据了。如果真的这样发生了，那就相当于数据库没有一点保护措施。</p><h3 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h3><h4 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h4><p>也是业内最常用的方案，保留中间状态，比如增加操作日志 <code>commit log</code>，也叫做<code>Write-Ahead-log</code>（提前记录日志)。在保存用户信息之前，先写入一个 commit log 中（<strong>这个磁盘操作可以顺序追加，比正常写快 10 多倍</strong>），写完之后，就可以提交该事务了。至于 commit log 搬运到对应的数据库位置，可以用定时任务刷新。</p><blockquote><p>说明一下，这个方案为什么能解决问题。<br>第一种情况：commit log 写失败，当作事务失败，这部分数据丢弃了，也没有影响到正常数据<br>第二种情况：commit log 写成功，事务成功，数据库数据的迁移，无论是否 crash，都可以利用 commit log 的数据进行恢复操作，重试几次，总会成功</p></blockquote><p><code>commit log</code> 的意义就是为正式数据提交保留了一个数据备份和事务是否提交的标识。<br>方案缺陷：大数据量变更场景下存在性能问题。因为数据库数据必须在 commit log 的数据提交之后才能开始移动。而 commit log 一般保留的是数据的物理备份，而不是 sql 一样的逻辑备份，大数据量场景下保存的数据会比较多。影响了整体系统的吞吐量。</p><h4 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h4><p>再引入一个 undo log，它与 commit log 不太一样，它是保存数据发生变更之前的原版本，记录下原数据本身，就可以放心的在事务提交之前对数据进行修改。一旦发生什么问题，都可以回滚到原始版本数据。</p><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>MySQL经典三个文件的对比</p><table><thead><tr><th></th><th>bin log</th><th>redo log</th><th>undo log</th></tr></thead><tbody><tr><td>数据内容</td><td>保存执行的sql</td><td>记录具体在哪个数据块修改的最新内容</td><td>记录与此次执行内容相反的操作，也是一个sql</td></tr><tr><td>处理事务粒度</td><td>一个事务</td><td>以一个事务为粒度</td><td>以一条具体的数据为粒度</td></tr><tr><td>提供的能力</td><td>主从复制，数据崩溃恢复</td><td>事务 crash 后的恢复数据的能力，事务提交的标志是 redo log 有没有记录最后的 commit record，没有记录就当作事务失败，丢弃这个变更。无论怎么样，都不会影响实际的数据</td><td>提供行记录的历史版本，让记录 redo log 时可以放心的修改数据库数据，有数据的历史版本就不怕不能回滚</td></tr><tr><td>核心功能</td><td>主从复制</td><td>保障持久性，即 crash-safe，顺序读写加快读写速度</td><td>记录历史版本数据，也可用于 MVCC</td></tr><tr><td>落盘时机</td><td>redo日志落盘之前</td><td>事务提交之前落盘(因为redo log在内存有缓冲区，实际落盘时间可以配置的，默认是提交前落盘)</td><td>落盘时机是在事务提交之前</td></tr></tbody></table><h3 id="引申一下"><a href="#引申一下" class="headerlink" title="引申一下"></a>引申一下</h3><p>我们可能会看过bin log和redo log有一个<code>二阶段提交</code>。确保 binlog 和 redo log 在事务提交前保持一致。这个实际上和MySQL的持久化能力无关的，主要是为了保证MySQL的主库和从库的数据一致性。MySQL使用bin log做从库的数据同步，使用redo log做主库的崩溃恢复，两个日志内容保持一致才是可以保证主从的一致性，所以这个<code>二阶段提交</code>更多是一个分布式事务的操作。具体过程：</p><ol><li>第一阶段：准备阶段（Prepare Phase）</li></ol><p>当事务执行完毕，MySQL 准备提交时，它首先会将事务的修改记录写入 redo log，并将 redo log 标记为 PREPARED 状态。<br>此时，redo log 并不会立即提交，而是先记录事务的修改，但还未正式完成事务。<br>在此阶段，binlog 也会生成，并暂时存储在内存的缓存中。<br>目的：这一步确保如果系统在接下来崩溃，重启时 MySQL 可以通过 redo log 来判断这个事务是未完成的，不会丢失事务修改。</p><ol start="2"><li>第二阶段：提交阶段（Commit Phase）</li></ol><p>MySQL 首先将 binlog 刷入磁盘，确保二进制日志持久化。<br>然后将 redo log 标记为 COMMITTED 状态，并将其刷入磁盘。这时，事务正式完成并提交。<br>目的：确保当事务提交时，binlog 和 redo log 都已经持久化到磁盘，并且保持一致。如果此时系统崩溃，可以使用这两个日志来恢复事务。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>事务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大模型-未来已来</title>
    <link href="/2023/11/05/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%9D%82%E8%B0%88/"/>
    <url>/2023/11/05/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%9D%82%E8%B0%88/</url>
    
    <content type="html"><![CDATA[<p>最近参加公司举办的 AIGC 比赛，准备过程中开始学习如何使用 chatgpt，也就是接触了提示工程学科。非常震惊于大模型的能力，掌握一定诀窍的和它对话，如同和一个领域专家对话。</p><h3 id="理解人工智能的思维"><a href="#理解人工智能的思维" class="headerlink" title="理解人工智能的思维"></a>理解人工智能的思维</h3><p>人工智能的大脑由数十亿个人工神经元组成。这些神经元的结构被称为 transformer 架构，它是一种相当复杂的神经网络类型。你需要了解的是：</p><ol><li>这些人工智能只是数学函数。它们更像是f(成千上万的变量) &#x3D; 成千上万种可能的输出</li><li>这些人工智能通过将句子分解成称为标记（tokens）的单词&#x2F;子单词（例如，AI 可能将 “I don’t like” 作为 “”I”, “don”, “‘t” “like””））来理解句子。然后，每个标记都被转换为一组数字，以便人工智能进行处理。</li><li>这些人工智能根据前面的单词&#x2F;标记预测句子中的下一个单词&#x2F;标记（例如，人工智能可能会在 “I don’t like” 后面预测 “apples”）。它们写下的每个标记都基于它们以前看到和写下的标记；每次它们写下一个新标记时，它们都会停下来思考下一个标记应该是什么。</li><li>这些人工智能同时查看每个标记。它们不像人类那样从左到右或从右到左阅读。<br>个人感觉人工智能整体表现的能力和人类的思维特别像。最神奇的是目前人类也不知道“大力出奇迹”的训练结果会产生这么“变态”的“涌现”能力，整个大模型的原理目前看来还是一个黑盒，我们只能借助提示工程去发挥它的能力。<br>我猜想，如果搞个机器人，给它装上各种传感器，让它可以看到世界，并且提前训练好对外界事物的认知模型，配上大模型作为核心大脑，那一个真正意义上的机器人真的造出来了。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><blockquote><p>本篇随笔不具备专业角度，需要理性看待</p></blockquote><p>了解了它的能力，我觉得它对我的生活有如下改变：</p><ol><li>将它融入日常的 API 和新的编程语言学习过程中，它处理代码能力是非常强的。同时，也应该明白会编程语言已经不构成技术优势了。底层原理，工作经验才是更重要的</li><li>专注于训练逻辑推理能力，目前大模型欠缺的就是逻辑推理能力，而科研人员目前都不知道大模型的能力是怎么产生的，我想，短时间内，大模型肯定无法解决这个问题的</li><li>大模型的能力不可怕，可怕的是极其擅长使用大模型的人。</li><li>一些日常的文档梳理，甚至博客都可以让大模型代笔，毕竟自己的文字有的时候逻辑都不通。</li><li>关注于新技术，大模型今年年初就爆火了，当时没有深入了解它的能力，现在确实是有点晚了</li></ol>]]></content>
    
    
    <categories>
      
      <category>杂谈</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随笔</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>netty开篇--网络编程的这些事儿</title>
    <link href="/2023/10/25/netty%E5%BC%80%E7%AF%87--%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E8%BF%99%E4%BA%9B%E4%BA%8B%E5%84%BF/"/>
    <url>/2023/10/25/netty%E5%BC%80%E7%AF%87--%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E8%BF%99%E4%BA%9B%E4%BA%8B%E5%84%BF/</url>
    
    <content type="html"><![CDATA[<h3 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h3><p>官网介绍：<br>Netty is an <strong>asynchronous</strong> <strong>event-driven</strong> network application framework for rapid development of maintainable high performance protocol servers &amp; clients.<br>异步指的是 IO 模型。<br>事件驱动指的是线程模型。<br>为了让大家更好的理解，我们回顾一下操作系统提供的网络模型。</p><h3 id="Linux-的-IO-模型"><a href="#Linux-的-IO-模型" class="headerlink" title="Linux 的 IO 模型"></a>Linux 的 IO 模型</h3><p>先看一个简单的 web 程序，下面是客户端代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> &#123;<br>    ......<br>    <span class="hljs-comment">// 创建一个socket</span><br><span class="hljs-type">int</span> socketfd = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>......<br><span class="hljs-comment">// 连接服务器</span><br>connect(socketfd, &amp;serverAddr, <span class="hljs-keyword">sizeof</span>(serverAddr));<br>......<br><span class="hljs-comment">// 读取数据</span><br><span class="hljs-type">int</span> n = read(socketfd, buffer, <span class="hljs-keyword">sizeof</span>(buffer));<br>......<br>&#125;<br></code></pre></td></tr></table></figure><p>上面省略了其他代码，可以看出主要的步骤就 3 步：</p><ol><li>创建 socket</li><li>连接服务器</li><li>读写数据<br>对于 Linux 来说，网络编程是面向 socket 编程，可以看到调用系统方法 <code>socket</code> 返回的是一个类似文件描述符的整数，操作系统认为打开网络连接和打开磁盘文件是一致的，都会返回一个文件描述符，也都会有一个对应的内核缓冲区，对 socket 来说，也叫做 <code>socket缓冲区</code>。<br>继续看一个服务端例子：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> **argv)</span> &#123;<br>    ......<br>    <span class="hljs-comment">// 创建一个socket</span><br><span class="hljs-type">int</span> listenfd = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);<br>......<br><span class="hljs-comment">// 绑定需要监听的地址</span><br>bind(listenfd, &amp;serverAddr, <span class="hljs-keyword">sizeof</span>(serverAddr));<br><span class="hljs-comment">// 监听端口号</span><br>listen(listenfd, null);<br>......<br><span class="hljs-keyword">for</span>(;;) &#123;<br><span class="hljs-comment">// 等待客户端连接</span><br><span class="hljs-type">int</span> socketfd = accept(listenfd, null, null);<br>......<br><span class="hljs-comment">// 读写数据</span><br><span class="hljs-type">int</span> n = read(socketfd, buffer, <span class="hljs-keyword">sizeof</span>(buffer));<br>......<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>服务端稍微麻烦了一些，需要 5 个步骤：</li><li>创建 socket</li><li>绑定监听地址，尤其是端口号，监听的客户端 IP 的范围</li><li>开始监听</li><li>等待客户端连接，有了新连接，则会创建新的 socket，标识唯一的 C-S 连接</li><li>在新的 socket 上读写数据<br>有了 web 编程的基本印象，接下来可以介绍 linux 经典的 5 个网络模型了，但其中的信号驱动模型不怎么常用，就不做介绍了。<br><img src="https://raw.githubusercontent.com/ttoobbyyy/images/master/20231025090154.png"><br>我们知道，数据从机器 A 传输到机器 B，中间会经过机器 A 的数据从内存复制到网卡，再经过网络，再到达机器 B 的网卡，再到达机器 B 的内核空间。对于机器 B 来说，可以将数据传输阶段分为两个阶段：<br>阶段一：数据传输到机器 B 的内核空间，过程中不需要 cpu 参与<br>阶段二：数据从机器 B 的内核空间复制到应用空间</li></ol><h4 id="1-阻塞-IO"><a href="#1-阻塞-IO" class="headerlink" title="1. 阻塞 IO"></a>1. 阻塞 IO</h4><p><img src="https://raw.githubusercontent.com/ttoobbyyy/images/master/20231025090239.png"><br>对于阻塞 IO 来说，应用程序发起读写系统调用，应用线程两个阶段都是在等待，从应用程序的角度来说就是被阻塞住了。</p><h4 id="2-非阻塞-IO"><a href="#2-非阻塞-IO" class="headerlink" title="2. 非阻塞 IO"></a>2. 非阻塞 IO</h4><p><img src="https://raw.githubusercontent.com/ttoobbyyy/images/master/20231025090941.png"><br>要使用非阻塞 IO，必须在创建 socket 的时候显示声明为非阻塞的。这时候，应用程序发起读写系统调用，如果第一阶段数据没有准备好，那么会直接返回 error。这样就不会阻塞住了，不过应用程序需要过段时间就去尝试调用一次。<br>当第一阶段完成时，系统调用就会执行第二阶段，整个过程还是阻塞的。完成第二阶段的数据拷贝才会返回成功。</p><h4 id="3-IO-多路复用"><a href="#3-IO-多路复用" class="headerlink" title="3. IO 多路复用"></a>3. IO 多路复用</h4><p>IO 多路复用是现在高性能网络的基石。<br>对于单个连接而言，它的两个阶段都是阻塞的，和阻塞 IO 是一致的。<br>然而对于整体系统而言，所有连接的第一阶段可以由单一线程来统一管理，而第二阶段才需要特定线程来处理。并且，第一阶段的耗时比第二阶段耗时要高很多。IO 多路复用相比阻塞 IO 能大大提高系统的吞吐量。<br><img src="https://raw.githubusercontent.com/ttoobbyyy/images/master/20231025091009.png"><br>第一阶段使用 select 系统调用（或者 poll，epoll），这个对于应用程序来说还是阻塞的，当第一阶段完成才会返回结果。第二阶段调用读写方法，也是阻塞的</p><h4 id="4-异步-IO"><a href="#4-异步-IO" class="headerlink" title="4. 异步 IO"></a>4. 异步 IO</h4><p>上面三种都是阻塞的 IO 模型，只有这一种是完全不阻塞的。不阻塞也很好理解，可以简单认为两个阶段的数据运输工作，都由其他线程完成了，和应用程序的用户线程无关。<br><img src="https://raw.githubusercontent.com/ttoobbyyy/images/master/20231025091028.png"><br>遗憾的是，Linux 系统目前对异步 IO 模型支持的不好，本身很受限制，在 Java 平台的异步 IO 都是用 JVM 自己创建的线程池。</p><h3 id="JavaNIO"><a href="#JavaNIO" class="headerlink" title="JavaNIO"></a>JavaNIO</h3><p>JavaNIO 指的是 Java new IO，主要包含 IO 多路复用和异步 IO。其中有三个核心的组件：<br>Buffer，Channel，Selector，它们的关系如下：<br><img src="https://raw.githubusercontent.com/ttoobbyyy/images/master/20231025091048.png"><br>Java 本身也是利用了操作系统的底层能力，三个组件可以这样理解：</p><ol><li>Buffer： socket 缓冲区在用户程序空间的对应区域</li><li>Channel：相当于 socket，属于 Selector 管理的基本单位</li><li>Selector：类似监听 socket IO 事件的线程，主要负责第一阶段的数据传输<br>为了加深大家的印象，可以看看如下的一个服务端案例：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">String</span> <span class="hljs-variable">demo_text</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;This is a demo String&quot;</span>;<br><span class="hljs-comment">// 1. 创建selector</span><br><span class="hljs-type">Selector</span> <span class="hljs-variable">selector</span> <span class="hljs-operator">=</span> Selector.open();<br><br><span class="hljs-comment">// 2. 做好服务端的准备工作，socket的创建，绑定，监听</span><br><span class="hljs-type">ServerSocketChannel</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> ServerSocketChannel.open();  <br>serverSocket.bind(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(<span class="hljs-string">&quot;localhost&quot;</span>, <span class="hljs-number">5454</span>));  <br>serverSocket.configureBlocking(<span class="hljs-literal">false</span>);  <br><br><span class="hljs-comment">// 3. 将服务端socket注册到选择器上，注册的事件是accept事件</span><br>serverSocket.register(selector, SelectionKey.OP_ACCEPT);  <br><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocate(<span class="hljs-number">256</span>);  <br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br><span class="hljs-comment">// 4. selector开始监听，方法是阻塞的，有channel准备好才会返回</span><br>    selector.select();  <br>    Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();  <br>    Iterator&lt;SelectionKey&gt; iter = selectedKeys.iterator();<br>    <br><span class="hljs-comment">// 5. 遍历准备好的channel</span><br>    <span class="hljs-keyword">while</span> (iter.hasNext()) &#123;  <br>        <span class="hljs-type">SelectionKey</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> iter.next();  <br>        <span class="hljs-type">int</span> <span class="hljs-variable">interestOps</span> <span class="hljs-operator">=</span> key.interestOps();  <br>        System.out.println(interestOps);<br>        <br>        <span class="hljs-comment">// accept事件</span><br>        <span class="hljs-keyword">if</span> (key.isAcceptable()) &#123;  <br>            <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> serverSocket.accept();  <br>            client.configureBlocking(<span class="hljs-literal">false</span>);  <br>            client.register(selector, SelectionKey.OP_READ);  <br>        &#125;<br>        <br>    <span class="hljs-comment">// 读事件</span><br>        <span class="hljs-keyword">if</span> (key.isReadable()) &#123;  <br>            <span class="hljs-type">SocketChannel</span> <span class="hljs-variable">client</span> <span class="hljs-operator">=</span> (SocketChannel) key.channel();  <br>            client.read(buffer);  <br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer.array()).trim().equals(demo_text)) &#123;  <br>                client.close();  <br>                System.out.println(<span class="hljs-string">&quot;Not accepting client messages anymore&quot;</span>);  <br>            &#125;  <br>            buffer.flip();  <br>            client.write(buffer);  <br>            buffer.clear();  <br>        &#125;<br>        iter.remove();  <br>    &#125;  <br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h3 id="netty-VS-JavaNIO"><a href="#netty-VS-JavaNIO" class="headerlink" title="netty VS JavaNIO"></a>netty VS JavaNIO</h3><p>有了以上的铺垫，可以开始介绍主角 netty 了。我们说 netty 的定位是对 JavaNIO 的封装，相比于 JavaNIO，netty 的优点有下面几个：</p><ol><li>NIO 的类库和 API 不好使用，netty 屏蔽了 NIO 的 Selector、ServerSocketChannel、SocketChannel、ByteBuffer 等抽象概念</li><li>使用 NIO 用户需要熟悉网络编程的原理，还得了解 Reactor 等高性能网络模式，才能写出高质量 NIO 程序。而 netty 套个简单的模板就能使用了，屏蔽了网络细节</li><li>使用 NIO 需要考虑一些异常情况，比如：客户端断连重连，网络闪断，半包读写，异常码的处理等，而 netty 也屏蔽了这些细节</li></ol><h3 id="netty-线程模型"><a href="#netty-线程模型" class="headerlink" title="netty 线程模型"></a>netty 线程模型</h3><p>netty 的非阻塞所使用的 IO 模型是 IO 多路复用。而它使用的线程模型是 <strong>Reactor 模型</strong>。<br>Reactor 模型，是指通过一个或多个输入同时传递给服务处理器的服务请求的<strong>事件驱动处理模式</strong>。 服务端程序处理传入多路请求，并将它们同步分派给请求对应的处理线程，Reactor 模式也叫 Dispatcher 模式，即 I&#x2F;O 多了复用统一监听事件，收到事件后分发（Dispatch 给某 handle 线程）<br>Reactor 模型中有 2 个关键组件：</p><ol><li>Reactor：负责监听和分发事件，在单独的线程中运行</li><li>Handler：执行事件的处理程序，可以有不同的实现方案，新建线程，线程池等<br><img src="https://raw.githubusercontent.com/ttoobbyyy/images/master/20231025091106.png"><br>取决于 Reactor 的数量和 Hanndler 线程数量的不同，Reactor 模型有 3 个变种：</li></ol><ul><li>单 Reactor 单线程</li><li>单 Reactor 多线程</li><li>主从 Reactor 多线程<br>netty 采用的就是主从 Reactor 多线程模式，相比于其他，采用这个模式有两个优点：</li></ul><ol><li>主从 Reactor，主 Reactor 只负责处理 accept 事件，建立连接，其他的读写事件由从 Reactor 处理。避免了在高并发场景下，Reactor 处理线程成为性能瓶颈</li><li>多线程能充分利用现代处理器多核的特性<br><img src="https://raw.githubusercontent.com/ttoobbyyy/images/master/20231025091131.png"><br>上图就是 netty 的 Reactor 模型的实际实现，整体上还是能看出主从 Reactor 模型的轮廓的，为了让大家能更清晰的理解，必须开始一段枯燥的名词解释：</li></ol><ul><li>Channel：网络通信的基本组件，可理解为 Linux 中的 socket</li><li>Selector：用于监听连接的 Channel 事件</li><li>NioEventLoop：维护了一个线程和任务队列，支持异步提交执行任务</li><li>NioEventLoopGroup：可以理解为一个线程池，内部维护了一组线程（NioEventLoop）</li><li>ChannelHandler：业务处理操作</li><li>ChannelPipline：多个 ChannelHandler 组合成的处理链路，一个 Channel 包含了一个 ChannelPipeline<br>使用 netty 写服务端代码也异常简洁：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br><span class="hljs-comment">// 创建mainReactor</span><br><span class="hljs-type">NioEventLoopGroup</span> <span class="hljs-variable">boosGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br><span class="hljs-comment">// 创建工作线程组</span><br><span class="hljs-type">NioEventLoopGroup</span> <span class="hljs-variable">workerGroup</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br><br><span class="hljs-keyword">final</span> <span class="hljs-type">ServerBootstrap</span> <span class="hljs-variable">serverBootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>();<br>serverBootstrap <br> <span class="hljs-comment">// 组装NioEventLoopGroup </span><br>.group(boosGroup, workerGroup)<br> <span class="hljs-comment">// 设置channel类型为NIO类型</span><br>.channel(NioServerSocketChannel.class)<br><span class="hljs-comment">// 设置连接配置参数</span><br>.option(ChannelOption.SO_BACKLOG, <span class="hljs-number">1024</span>)<br>.childOption(ChannelOption.SO_KEEPALIVE, <span class="hljs-literal">true</span>)<br>.childOption(ChannelOption.TCP_NODELAY, <span class="hljs-literal">true</span>)<br><span class="hljs-comment">// 配置入站、出站事件handler</span><br>.childHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;NioSocketChannel&gt;() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(NioSocketChannel ch)</span> &#123;<br><span class="hljs-comment">// 配置入站、出站事件channel</span><br>ch.pipeline().addLast(...);<br>ch.pipeline().addLast(...);<br>&#125;<br>&#125;);<br><br><span class="hljs-comment">// 绑定端口</span><br><span class="hljs-type">int</span> <span class="hljs-variable">port</span> <span class="hljs-operator">=</span> <span class="hljs-number">8080</span>;<br>serverBootstrap.bind(port).addListener(future -&gt; &#123;<br><span class="hljs-keyword">if</span> (future.isSuccess()) &#123;<br>System.out.println(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>() + <span class="hljs-string">&quot;: 端口[&quot;</span> + port + <span class="hljs-string">&quot;]绑定成功!&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>System.err.println(<span class="hljs-string">&quot;端口[&quot;</span> + port + <span class="hljs-string">&quot;]绑定失败!&quot;</span>);<br>&#125;<br>&#125;);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>明白整个网络编程的基本运行原理对平时工作还是有很大帮助的。无论使用什么编程语言底层都是依靠操作系统提供的能力，理解socket编程可以一通百通。接下来会介绍netty的具体技术点，从哪方面切入还没有想好。</p><h3 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h3><p><a href="https://www.jianshu.com/p/2965fca6bb8f">理解高性能网络模型 - 简书 (jianshu.com)</a><br><a href="https://book.douban.com/subject/4118578/">UNIX网络编程 卷1</a></p>]]></content>
    
    
    <categories>
      
      <category>中间件</category>
      
    </categories>
    
    
    <tags>
      
      <tag>netty</tag>
      
      <tag>网络编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据库事务--开篇介绍(1)</title>
    <link href="/2023/10/22/MySQL%E4%BA%8B%E5%8A%A1%E7%B3%BB%E5%88%97--%E4%BB%8B%E7%BB%8D/"/>
    <url>/2023/10/22/MySQL%E4%BA%8B%E5%8A%A1%E7%B3%BB%E5%88%97--%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h3 id="事务的定义"><a href="#事务的定义" class="headerlink" title="事务的定义"></a>事务的定义</h3><p>百度百科：</p><blockquote><p>事务（Transaction），一般是指要做的或所做的事情。在计算机术语中是指访问并可能更新数据库中各种数据项的一个程序执行单元(unit)。</p></blockquote><p>百科的描述是很模糊的，不过事务的本身确实仅仅指的一些程序操作，只不过这些操作具备 ACID 特性。于是，我们可以将事务定义为<strong>具备 ACID 特性的多个程序执行指令。</strong><br>我们以小明向小红转账 100 元为例说明这几个特性。对于转账操作，可以拆分为两个步骤：</p><ol><li>小明账户减去 100 元 </li><li>小红账户加上 100 元<br>这两个步骤合起来称为一个事务。</li></ol><h4 id="A-原子性"><a href="#A-原子性" class="headerlink" title="A-原子性"></a>A-原子性</h4><p>事务中的操作要么全部成功，要不全部失败。<br>对于转账操作，要么成功转账，要么失败。不存在小明账户扣完 100 元，而小红账户没变化。</p><h4 id="C-一致性"><a href="#C-一致性" class="headerlink" title="C-一致性"></a>C-一致性</h4><p>一致性是指一个业务操作完成，存储系统中的数据符合业务操作的预期结果。不存在中间状态。<br>对于转账这个业务操作，操作成功就是小红账户和小明账户分别加减 100 元，失败就是账户没有变化。这两种都符合对于业务操作的预期结果，都满足了一致性要求。</p><h4 id="I-隔离性"><a href="#I-隔离性" class="headerlink" title="I-隔离性"></a>I-隔离性</h4><p>多个事务之间不能互相干扰。<br>假如小军也给小红转了 100 元，那么这两个转账操作的最终结果就是小红账户多了 200 元，不能因为并行执行而影响最终结果。<br>隔离性因为涉及到了并发操作，比较复杂，根据不同的隔离级别可以分为<strong>串行化，可重复读，读已提交，读未提交</strong>。这些隔离级别的实现后续会分析的。</p><h4 id="D-持久性"><a href="#D-持久性" class="headerlink" title="D-持久性"></a>D-持久性</h4><p>事务提交后，它的改变就是永久性的，后续的操作和故障不会对其造成影响。<br>简单理解就是数据落盘了，内存会因为机器断电而丢失数据，但磁盘不会。</p><h4 id="我的理解"><a href="#我的理解" class="headerlink" title="我的理解"></a>我的理解</h4><p><strong>AID 是特性，C 是目的</strong>。MySQL 为 AID 特性做了大量的设计工作，而 C 正是这些特性带来的最终效果。</p><h3 id="事务的意义"><a href="#事务的意义" class="headerlink" title="事务的意义"></a>事务的意义</h3><p>事务对一个健全后端服务非常重要。传统的讲究一个 ACID，不过，事务的本质也就是提供了一个 C。数据一致性很重要，如果资源成本足够低的话，所有的后端服务都能保持一致性是大家都愿意做的事情。<br>那么一致性面对的问题有什么呢？</p><ol><li>高并发场景，有可能会丢失变更等一系列不符合原有逻辑的情况</li><li>机器不可靠，网络不可靠，一切服务的基础组件都不可靠，随时面临崩溃<br>事务，就是用来解决这两个问题的。隔离性解决了高并发场景问题，原子性和持久性解决基础组件不可靠的问题。<br>NoSql 无法替代传统关系型数据库的关键原因，也是它无法提供事务特性。像 redis 的事务都是一些不完整的事务，压根保证不了一致性。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><strong>事务的本质是保证数据的一致性</strong>。<br>能提供一致性的事务固然强大，但是否要使用还是要根据业务场景的，如果 qps 特别高，是否真的有需求保证数据一致性就真的要好好考虑了，这个成本可不低。<br>后续的文章会开始介绍 AID 在 MySQL 中是如何实现的。</p>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据库</tag>
      
      <tag>事务</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
