<html>

<head>
    <meta charset="utf-8">
    <title>2025, 快乐永伴</title>
    <meta name="language" content="zh-CN">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <link rel="icon" type="image/x-icon" href="https://cdn.jsdelivr.net/gh/sun0225SUN/photos/img/20210715233345.png">
    <link href="css/hovertreewelcome.css" type="text/css" rel="stylesheet">
    <style>
        #letter {
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            position: relative;
            z-index: 100;
            text-align: left;
            line-height: 1.8;
            overflow-y: auto;
            max-height: 80vh;
            color: white;
            font-family: "Microsoft YaHei", "微软雅黑", sans-serif;
            font-size: 16px;
            /* 隐藏滚动条但保留滚动功能 */
            scrollbar-width: none;
            /* Firefox */
            -ms-overflow-style: none;
            /* IE and Edge */
        }

        /* 针对Webkit浏览器（Chrome、Safari等）隐藏滚动条 */
        #letter::-webkit-scrollbar {
            display: none;
        }

        #letter p {
            margin-bottom: 15px;
        }

        .cursor {
            display: inline-block;
            width: 2px;
            height: 20px;
            background-color: white;
            animation: blink 0.7s infinite;
        }

        @keyframes blink {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0;
            }
        }

        #hovertreecontainer {
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            position: relative;
        }

        h1 {
            text-align: center;
            color: #ff6b81;
            margin-bottom: 20px;
            font-family: "Microsoft YaHei", "微软雅黑", sans-serif;
            font-size: 24px;
        }

        #content {
            font-size: 16px;
            line-height: 1.8;
        }

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
        }
    </style>
</head>

<body>
    <div id="hovertreecontainer">
        <div id="letter">
            <h1>给我亲爱的缘缘</h1>
            <div id="content"></div>
            <span class="cursor"></span>
        </div>
    </div>

    <canvas id="canvas"></canvas>
    <audio autoplay="autoplay" loop>
        <source src="music.mp3" type="audio/mpeg">
        您的浏览器不支持播放音乐。请用支持html5的浏览器打开,例如chrome或火狐或者新版IE等。
    </audio>
    <script type="text/javascript" src="js/hovertreewelcome.js">
    </script>
    <script type="text/javascript">
        // 打字机效果
        const text = `缘缘，
我已经陪你一年了哦，看着去年给你写的，真的老脸一红，去年一定是被你这个小妖精下魅毒了！我怎么会写出这么幼稚的情话！我可是深情小王子！咳咳，这个你无法反驳吧（这时候沉默是金/手动狗头）

时间真的过的好快呀！有你陪着的时间更是飞快，一个月盼着下个月，每天都有期待，生活有了期待，过的确实更快了，每次见面都会有不同的感受，唯一相同的是分别的无奈，哪怕经历了这么多次，真的走的时候还是很难受。能安慰自己的是，这种时间是有尽头的。我们终将会长久在一起！

这一年，我们经历了好多酸甜苦辣。导致这些的原因是我选择了 pdd，是我向自己妥协了，向自己低头了，对不起，要是没有选择 pdd，我会有更多的时间，更多的精力，我们也会有更近的距离。只是 pdd 确实是互联网的另类，强度大+无社交+涨薪快，我想用时间换钱，也是对自己性格的妥协了。对不起，宝贝。我给我们的感情平添了很多麻烦。

不过呢，我感觉这一年我们都成长了好多呀。宝贝和我一直都在进步。我们吵架的频率越来越少，越来越为对方考虑，现在，每次我平静下来，盯着你看的时候，我能看到我的未来。我的内心在告诉我，未来，就在我的眼前。宝贝，你是我的未来哦！

现在想起来，总是会不自觉的微笑，看着聊天记录，都是镜像的一二布布表情包大战，当爱你已经成为一件如同呼吸一样再正常不过的事情，我感觉这个好奇妙呀。

谢谢宝贝，
谢谢你的宽容，陪着不懂事的我慢慢的成长，
谢谢你的耐心，每个调皮的布布都有可爱的一二回应，
我有所求，你有所应，
你有所求，我有所应，
我想，这也是爱情吧！

写给你的贺卡，如同总结我的一年感情经历，宝贝，我真的成长好多呢！
具体来说，就是将沟通具象化了，以前想着一定要多沟通，实际实施起来还是很有难度的。现在会想着把所有信息传达到位，一定会尽可能沟通到位。

宝贝呀，最后来矫情一下，嘿嘿！
我说出要去上海的那晚，你在我怀里哭泣，是爱情的苦涩，
你北京飞来见我，下班后在公寓楼下冲向你的时候，是爱情的甜蜜，
每次分别时，恋恋不舍的频频回头，
每次相见时，赖在对方身上不肯起开，
虹桥，首都，大兴飞机的起起落落，见证了我们对爱情的坚守！
我们经历的所有，都将成为爱情最美好的注脚。
我爱你，像呼吸一样的稀疏平常，
我爱你，是我对未来的最美好的期待。
你，吴清缘，即是我之未来！
生日快乐哦，我的臭宝贝！`;

        let i = 0;
        const contentElement = document.getElementById('content');

        function typeWriter() {
            if (i < text.length) {
                if (text.charAt(i) === '\n') {
                    contentElement.innerHTML += '<br>';
                } else {
                    contentElement.innerHTML += text.charAt(i);
                }
                i++;

                // 滚动到底部
                contentElement.parentElement.scrollTop = contentElement.parentElement.scrollHeight;

                // 调整打字速度，降低速度
                const speed = text.charAt(i - 1) === '\n' ? 800 : Math.random() * 100 + 100;
                setTimeout(typeWriter, speed);
            }
        }

        // 确保字体在移动端一致
        function setFontSize() {
            const vh = window.innerHeight * 0.01;
            document.documentElement.style.setProperty('--vh', `${vh}px`);

            // 确保字体大小一致
            const fontSize = Math.min(window.innerWidth / 30, 18);
            document.getElementById('content').style.fontSize = `${fontSize}px`;
            document.querySelector('h1').style.fontSize = `${fontSize * 1.5}px`;
        }

        // 页面加载和调整大小时设置字体
        window.addEventListener('resize', setFontSize);
        window.addEventListener('orientationchange', setFontSize);

        // 页面加载后开始打字效果
        window.addEventListener('load', function () {
            setFontSize();
            setTimeout(typeWriter, 1000);
        });

        ; (function (window) {

            var ctx,
                hue,
                logo,
                form,
                buffer,
                target = {},
                tendrils = [],
                settings = {};

            settings.debug = true;
            settings.friction = 0.5;
            settings.trails = 20;
            settings.size = 50;
            settings.dampening = 0.25;
            settings.tension = 0.98;

            Math.TWO_PI = Math.PI * 2;

            // ========================================================================================
            // Oscillator 
            // ----------------------------------------------------------------------------------------

            function Oscillator(options) {
                this.init(options || {});
            }

            Oscillator.prototype = (function () {

                var value = 0;

                return {

                    init: function (options) {
                        this.phase = options.phase || 0;
                        this.offset = options.offset || 0;
                        this.frequency = options.frequency || 0.001;
                        this.amplitude = options.amplitude || 1;
                    },

                    update: function () {
                        this.phase += this.frequency;
                        value = this.offset + Math.sin(this.phase) * this.amplitude;
                        return value;
                    },

                    value: function () {
                        return value;
                    }
                };

            })();

            // ========================================================================================
            // Tendril 
            // ----------------------------------------------------------------------------------------

            function Tendril(options) {
                this.init(options || {});
            }

            Tendril.prototype = (function () {

                function Node() {
                    this.x = 0;
                    this.y = 0;
                    this.vy = 0;
                    this.vx = 0;
                }

                return {

                    init: function (options) {

                        this.spring = options.spring + (Math.random() * 0.1) - 0.05;
                        this.friction = settings.friction + (Math.random() * 0.01) - 0.005;
                        this.nodes = [];

                        for (var i = 0, node; i < settings.size; i++) {

                            node = new Node();
                            node.x = target.x;
                            node.y = target.y;

                            this.nodes.push(node);
                        }
                    },

                    update: function () {

                        var spring = this.spring,
                            node = this.nodes[0];

                        node.vx += (target.x - node.x) * spring;
                        node.vy += (target.y - node.y) * spring;

                        for (var prev, i = 0, n = this.nodes.length; i < n; i++) {

                            node = this.nodes[i];

                            if (i > 0) {

                                prev = this.nodes[i - 1];

                                node.vx += (prev.x - node.x) * spring;
                                node.vy += (prev.y - node.y) * spring;
                                node.vx += prev.vx * settings.dampening;
                                node.vy += prev.vy * settings.dampening;
                            }

                            node.vx *= this.friction;
                            node.vy *= this.friction;
                            node.x += node.vx;
                            node.y += node.vy;

                            spring *= settings.tension;
                        }
                    },

                    draw: function () {

                        var x = this.nodes[0].x,
                            y = this.nodes[0].y,
                            a, b;

                        ctx.beginPath();
                        ctx.moveTo(x, y);

                        for (var i = 1, n = this.nodes.length - 2; i < n; i++) {

                            a = this.nodes[i];
                            b = this.nodes[i + 1];
                            x = (a.x + b.x) * 0.5;
                            y = (a.y + b.y) * 0.5;

                            ctx.quadraticCurveTo(a.x, a.y, x, y);
                        }

                        a = this.nodes[i];
                        b = this.nodes[i + 1];

                        ctx.quadraticCurveTo(a.x, a.y, b.x, b.y);
                        ctx.stroke();
                        ctx.closePath();
                    }
                };

            })();

            // ----------------------------------------------------------------------------------------

            function init(event) {

                document.removeEventListener('mousemove', init);
                document.removeEventListener('touchstart', init);

                document.addEventListener('mousemove', mousemove);
                document.addEventListener('touchmove', mousemove);
                document.addEventListener('touchstart', touchstart);

                mousemove(event);
                reset();
                loop();
            }

            function reset() {

                tendrils = [];

                for (var i = 0; i < settings.trails; i++) {

                    tendrils.push(new Tendril({
                        spring: 0.45 + 0.025 * (i / settings.trails)
                    }));
                }
            }

            function loop() {

                if (!ctx.running) return;

                ctx.globalCompositeOperation = 'source-over';
                ctx.fillStyle = 'rgba(8,5,16,0.4)';
                ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                ctx.globalCompositeOperation = 'lighter';
                ctx.strokeStyle = 'hsla(' + Math.round(hue.update()) + ',90%,50%,0.25)';
                ctx.lineWidth = 1;

                if (ctx.frame % 60 == 0) {
                    console.log(hue.update(), Math.round(hue.update()), hue.phase, hue.offset, hue.frequency, hue.amplitude);
                }

                for (var i = 0, tendril; i < settings.trails; i++) {
                    tendril = tendrils[i];
                    tendril.update();
                    tendril.draw();
                }

                ctx.frame++;
                ctx.stats.update();
                requestAnimFrame(loop);
            }

            function resize() {
                ctx.canvas.width = window.innerWidth;
                ctx.canvas.height = window.innerHeight;
            }

            function start() {
                if (!ctx.running) {
                    ctx.running = true;
                    loop();
                }
            }

            function stop() {
                ctx.running = false;
            }

            function mousemove(event) {
                if (event.touches) {
                    target.x = event.touches[0].pageX;
                    target.y = event.touches[0].pageY;
                } else {
                    target.x = event.clientX
                    target.y = event.clientY;
                }
                event.preventDefault();
            }

            function touchstart(event) {
                if (event.touches.length == 1) {
                    target.x = event.touches[0].pageX;
                    target.y = event.touches[0].pageY;
                }
            }

            function keyup(event) {

                switch (event.keyCode) {
                    case 32:
                        save();
                        break;
                    default:
                    // console.log(event.keyCode);
                }
            }

            function save() {

                if (!buffer) {

                    buffer = document.createElement('canvas');
                    buffer.width = screen.availWidth;
                    buffer.height = screen.availHeight;
                    buffer.ctx = buffer.getContext('2d');

                    form = document.createElement('form');
                    form.method = 'post';
                    form.input = document.createElement('input');
                    form.input.type = 'hidden';
                    form.input.name = 'data';
                    form.appendChild(form.input);

                    document.body.appendChild(form);
                }

                buffer.ctx.fillStyle = 'rgba(8,5,16)';
                buffer.ctx.fillRect(0, 0, buffer.width, buffer.height);

                buffer.ctx.drawImage(canvas,
                    Math.round(buffer.width / 2 - canvas.width / 2),
                    Math.round(buffer.height / 2 - canvas.height / 2)
                );

                window.open(buffer.toDataURL(), 'wallpaper', 'top=0,left=0,width=' + buffer.width + ',height=' + buffer.height);
            }

            window.requestAnimFrame = (function () {
                return window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || function (fn) { window.setTimeout(fn, 1000 / 60) };
            })();

            window.onload = function () {

                ctx = document.getElementById('canvas').getContext('2d');
                ctx.stats = new Stats();
                ctx.running = true;
                ctx.frame = 1;

                hue = new Oscillator({
                    phase: Math.random() * Math.TWO_PI,
                    amplitude: 85,
                    frequency: 0.0015,
                    offset: 285
                });

                document.addEventListener('mousemove', init);
                document.addEventListener('touchstart', init);
                document.body.addEventListener('orientationchange', resize);
                window.addEventListener('resize', resize);
                window.addEventListener('keyup', keyup);
                window.addEventListener('focus', start);
                window.addEventListener('blur', stop);

                resize();
            };

        })(window);

        // Stats构造函数
        function Stats() {
            this.update = function () { };
            this.domElement = document.createElement('div');
        }
    </script>
</body>

</html>